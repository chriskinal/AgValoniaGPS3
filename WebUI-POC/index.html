<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AgOpenGPS - WebGL POC</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
        }

        #app {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 64px 1fr;
            grid-template-rows: 1fr;
        }

        /* Left Navigation Bar */
        #nav-bar {
            background: rgba(30, 42, 56, 0.95);
            padding: 8px 4px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }

        .nav-btn {
            width: 56px;
            height: 56px;
            border: none;
            border-radius: 8px;
            background: rgba(44, 62, 80, 0.87);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
            padding: 8px;
        }

        .nav-btn img {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .nav-btn:active, .nav-btn.active {
            background: #1ABC9C;
        }

        .nav-btn:hover {
            background: rgba(52, 73, 94, 0.95);
        }

        /* Floating Panels */
        .floating-panel {
            position: absolute;
            left: 72px;
            top: 60px;
            background: rgba(30, 42, 56, 0.95);
            border-radius: 12px;
            padding: 0;
            min-width: 280px;
            max-width: 320px;
            z-index: 200;
            display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        .floating-panel.visible {
            display: block;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            cursor: move;
        }

        .panel-title {
            color: #1ABC9C;
            font-weight: bold;
            font-size: 16px;
        }

        .panel-close {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-close:hover {
            background: #E74C3C;
        }

        .panel-content {
            padding: 12px;
        }

        .panel-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .panel-btn {
            height: 48px;
            border: none;
            border-radius: 8px;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            text-align: left;
        }

        .panel-btn img {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .panel-btn:hover {
            background: rgba(52, 73, 94, 0.95);
        }

        .panel-btn:active {
            background: #1ABC9C;
        }

        .panel-btn.full-width {
            grid-column: span 2;
        }

        /* Map Container */
        #map-container {
            position: relative;
            overflow: hidden;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Status Panels */
        .status-panel {
            background: rgba(26, 26, 26, 0.8);
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-weight: bold;
        }

        #top-status {
            position: absolute;
            top: 16px;
            left: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
            pointer-events: none;
        }

        #top-status > * {
            pointer-events: auto;
        }

        #gps-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #gps-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2ecc71;
        }

        #speed-display {
            font-size: 20px;
        }

        #speed-display span {
            font-size: 12px;
            color: #888;
        }

        #xte-display {
            flex: 1;
            text-align: center;
        }

        #xte-display .label {
            color: #1ABC9C;
            font-size: 14px;
        }

        #xte-display .value {
            color: yellow;
            font-size: 32px;
        }

        #xte-display .unit {
            color: #888;
            font-size: 14px;
        }

        #heading-display {
            font-size: 20px;
        }

        #heading-display span {
            color: #888;
        }

        /* Right Controls */
        #right-controls {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            background: rgba(44, 62, 80, 0.87);
            color: white;
            font-size: 24px;
            cursor: pointer;
        }

        .control-btn:active {
            background: #1ABC9C;
        }

        /* Bottom Status */
        #bottom-status {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }

        .coord-label {
            font-size: 14px;
            font-weight: bold;
        }

        .coord-value {
            font-size: 16px;
        }

        #easting .coord-label { color: #3498DB; }
        #northing .coord-label { color: #E74C3C; }

        /* Simulator Panel Controls */
        .sim-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .sim-row {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        .sim-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .sim-section label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            text-align: center;
        }

        .sim-value {
            min-width: 50px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #1ABC9C;
        }

        .sim-btn {
            height: 36px;
            padding: 0 16px;
            border: none;
            border-radius: 6px;
            background: #34495E;
            color: white;
            font-size: 14px;
            cursor: pointer;
            min-width: 60px;
        }

        .sim-btn:hover {
            background: rgba(52, 73, 94, 0.95);
        }

        .sim-btn:active {
            background: #1ABC9C;
        }

        .sim-btn.active {
            background: #1ABC9C;
        }

        .sim-btn.danger {
            background: #8B0000;
        }

        .sim-btn.danger:hover {
            background: #A00000;
        }

        .sim-arrow {
            width: 36px;
            height: 36px;
            padding: 0;
            min-width: 36px;
            font-size: 16px;
        }

        .sim-steer-indicator {
            height: 8px;
            background: #2C3E50;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .sim-steer-bar {
            position: absolute;
            top: 0;
            height: 100%;
            width: 10px;
            background: #1ABC9C;
            border-radius: 4px;
            left: 50%;
            transform: translateX(-50%);
            transition: left 0.1s ease-out;
        }

        /* Current Field Display */
        .current-field {
            margin-top: 12px;
            padding: 10px 12px;
            background: rgba(39, 174, 96, 0.3);
            border-radius: 6px;
            border-left: 4px solid #27AE60;
            color: white;
            font-weight: bold;
            text-align: center;
        }

        .current-field.no-field {
            background: rgba(127, 140, 141, 0.3);
            border-left-color: #7F8C8D;
            color: #95A5A6;
        }

        /* Field List Modal */
        .field-list-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 42, 56, 0.98);
            border-radius: 12px;
            padding: 0;
            min-width: 300px;
            max-width: 400px;
            max-height: 70vh;
            z-index: 500;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            display: none;
        }

        .field-list-modal.visible {
            display: block;
        }

        .field-list-modal .panel-content {
            max-height: 50vh;
            overflow-y: auto;
        }

        .field-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .field-list-item {
            padding: 12px 16px;
            background: rgba(44, 62, 80, 0.8);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            transition: background 0.15s;
        }

        .field-list-item:hover {
            background: rgba(52, 73, 94, 0.95);
        }

        .field-list-item:active {
            background: #1ABC9C;
        }

        .field-list-empty {
            padding: 20px;
            text-align: center;
            color: #7F8C8D;
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 400;
            display: none;
        }

        .modal-backdrop.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Left Navigation -->
        <nav id="nav-bar">
            <button class="nav-btn" id="btn-file" title="File Menu"><img src="icons/fileMenu.png" alt="File"></button>
            <button class="nav-btn" id="btn-view" title="View Settings"><img src="icons/NavigationSettings.png" alt="View"></button>
            <button class="nav-btn" id="btn-tools" title="Tools"><img src="icons/SpecialFunctions.png" alt="Tools"></button>
            <button class="nav-btn" id="btn-config" title="Configuration"><img src="icons/Settings48.png" alt="Config"></button>
            <button class="nav-btn" id="btn-job" title="Job Menu"><img src="icons/JobActive.png" alt="Job"></button>
            <button class="nav-btn" id="btn-field" title="Field Tools"><img src="icons/FieldTools.png" alt="Field"></button>
            <button class="nav-btn" id="btn-steer" title="AutoSteer"><img src="icons/AutoSteerConf.png" alt="Steer"></button>
            <button class="nav-btn" id="btn-agio" title="Data I/O"><img src="icons/AgIO.png" alt="AgIO"></button>
        </nav>

        <!-- Map Area -->
        <div id="map-container">
            <canvas id="map-canvas"></canvas>

            <!-- Top Status Bar -->
            <div id="top-status">
                <div id="gps-status" class="status-panel">
                    <div id="gps-dot"></div>
                    <span id="fix-quality">RTK</span>
                </div>
                <div id="speed-display" class="status-panel">
                    <span id="speed-value">0.0</span> <span>km/h</span>
                </div>
                <div id="xte-display" class="status-panel">
                    <span class="label">XTE</span>
                    <span class="value" id="xte-value">0.00</span>
                    <span class="unit">m</span>
                </div>
                <div id="heading-display" class="status-panel">
                    <span id="heading-value">0</span><span>°</span>
                </div>
            </div>

            <!-- Right Controls -->
            <div id="right-controls">
                <button class="control-btn" id="zoom-in">+</button>
                <button class="control-btn" id="toggle-3d">3D</button>
                <button class="control-btn" id="zoom-out">−</button>
            </div>

            <!-- Bottom Position -->
            <div id="bottom-status" class="status-panel">
                <div id="easting">
                    <span class="coord-label">E</span>
                    <span class="coord-value" id="easting-value">0.0</span>
                </div>
                <div id="northing">
                    <span class="coord-label">N</span>
                    <span class="coord-value" id="northing-value">0.0</span>
                </div>
            </div>

            <!-- Simulator Control Panel (floating) -->
            <div id="panel-simulator" class="floating-panel" style="top: auto; bottom: 80px; left: 72px; min-width: 200px;">
                <div class="panel-header">
                    <span class="panel-title">Simulator</span>
                    <button class="panel-close" data-panel="simulator">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="sim-controls">
                        <div class="sim-row">
                            <button class="sim-btn" id="sim-toggle">Start</button>
                            <button class="sim-btn danger" id="stop">Reset</button>
                        </div>
                        <div class="sim-section">
                            <label>Speed</label>
                            <div class="sim-row">
                                <button class="sim-btn sim-arrow" id="decel">-</button>
                                <span class="sim-value" id="sim-speed-display">0</span>
                                <button class="sim-btn sim-arrow" id="accel">+</button>
                            </div>
                        </div>
                        <div class="sim-section">
                            <label>Steering</label>
                            <div class="sim-row">
                                <button class="sim-btn sim-arrow" id="steer-left">&#9664;</button>
                                <span class="sim-value" id="sim-steer-display">0°</span>
                                <button class="sim-btn sim-arrow" id="steer-right">&#9654;</button>
                            </div>
                            <div class="sim-row" style="justify-content: center;">
                                <button class="sim-btn" id="steer-zero">Center</button>
                            </div>
                            <div class="sim-steer-indicator">
                                <div class="sim-steer-bar" id="steer-bar"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Floating Panels -->
            <!-- File Menu Panel -->
            <div id="panel-file" class="floating-panel">
                <div class="panel-header">
                    <span class="panel-title">File Menu</span>
                    <button class="panel-close" data-panel="file">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn"><img src="icons/FileNew.png">New Profile</button>
                        <button class="panel-btn"><img src="icons/FileOpen.png">Load Profile</button>
                        <button class="panel-btn"><img src="icons/Settings48.png">Language</button>
                        <button class="panel-btn" id="panel-sim-btn"><img src="icons/vehiclePageTractor.png">Simulator</button>
                        <button class="panel-btn"><img src="icons/GPSQuality.png">Sim Coords</button>
                        <button class="panel-btn"><img src="icons/ScreenShot.png">Kiosk Mode</button>
                        <button class="panel-btn"><img src="icons/Reset_Default.png">Reset ALL</button>
                        <button class="panel-btn"><img src="icons/AgShare.png">About</button>
                        <button class="panel-btn full-width"><img src="icons/OK64.png">Help</button>
                    </div>
                </div>
            </div>

            <!-- View Settings Panel -->
            <div id="panel-view" class="floating-panel" style="top: 120px;">
                <div class="panel-header">
                    <span class="panel-title">View Settings</span>
                    <button class="panel-close" data-panel="view">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn">Tilt Down</button>
                        <button class="panel-btn">Tilt Up</button>
                        <button class="panel-btn" id="btn-2d3d">2D / 3D</button>
                        <button class="panel-btn" id="btn-north">North Up</button>
                        <button class="panel-btn" id="btn-grid-toggle">Grid</button>
                        <button class="panel-btn" id="btn-daynight">Day/Night</button>
                        <button class="panel-btn">Dim -</button>
                        <button class="panel-btn">Bright +</button>
                    </div>
                </div>
            </div>

            <!-- Tools Panel -->
            <div id="panel-tools" class="floating-panel" style="top: 180px;">
                <div class="panel-header">
                    <span class="panel-title">Tools</span>
                    <button class="panel-close" data-panel="tools">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn"><img src="icons/WizardWand.png">Steer Wizard</button>
                        <button class="panel-btn"><img src="icons/Boundary.png">Boundary Tool</button>
                        <button class="panel-btn"><img src="icons/AutoSteerOn.png">Steer Chart</button>
                        <button class="panel-btn"><img src="icons/ABSmooth.png">Smooth AB</button>
                        <button class="panel-btn"><img src="icons/ConS_SourcesHeading.png">Heading Chart</button>
                        <button class="panel-btn"><img src="icons/TrashContourRef.png">Del Contours</button>
                        <button class="panel-btn"><img src="icons/AutoManualIsAuto.png">XTE Chart</button>
                        <button class="panel-btn"><img src="icons/YouTurnReverse.png">Offset Fix</button>
                        <button class="panel-btn"><img src="icons/ConS_SourcesRoll.png">Roll Correction</button>
                        <button class="panel-btn"><img src="icons/ABTracks.png">Log Viewer</button>
                    </div>
                </div>
            </div>

            <!-- Configuration Panel -->
            <div id="panel-config" class="floating-panel" style="top: 240px;">
                <div class="panel-header">
                    <span class="panel-title">Configuration</span>
                    <button class="panel-close" data-panel="config">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn"><img src="icons/Settings48.png">Configuration</button>
                        <button class="panel-btn"><img src="icons/GPSQuality.png">GPS Data</button>
                        <button class="panel-btn"><img src="icons/AutoSteerOff.png">Auto Steer</button>
                        <button class="panel-btn"><img src="icons/ColourPick.png">Colors</button>
                        <button class="panel-btn"><img src="icons/ScreenShot.png">All Settings</button>
                        <button class="panel-btn"><img src="icons/SectionMapping.png">Section Colors</button>
                        <button class="panel-btn"><img src="icons/FileOpen.png">Directories</button>
                        <button class="panel-btn"><img src="icons/ConD_KeyBoard.png">HotKeys</button>
                    </div>
                </div>
            </div>

            <!-- Job Menu Panel -->
            <div id="panel-job" class="floating-panel" style="top: 300px; min-width: 320px;">
                <div class="panel-header">
                    <span class="panel-title">Start New Field</span>
                    <button class="panel-close" data-panel="job">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn" id="job-isoxml"><img src="icons/ISOXML.png">ISO-XML</button>
                        <button class="panel-btn" id="job-close"><img src="icons/FileClose.png">Close</button>
                        <button class="panel-btn" id="job-kml"><img src="icons/GoogleEarth.png">From KML</button>
                        <button class="panel-btn" id="job-drivein"><img src="icons/SteerDriveOn.png">Drive In</button>
                        <button class="panel-btn" id="job-existing"><img src="icons/FileExisting.png">From Existing</button>
                        <button class="panel-btn" id="job-open"><img src="icons/FileOpen.png">Open</button>
                        <button class="panel-btn" id="job-new"><img src="icons/FileNew.png">New Default</button>
                        <button class="panel-btn" id="job-resume"><img src="icons/FilePrevious.png">Resume</button>
                    </div>
                    <!-- Current Field Display -->
                    <div id="current-field-display" class="current-field" style="display: none;">
                        <span id="current-field-name">No field open</span>
                    </div>
                </div>
            </div>

            <!-- Field Tools Panel -->
            <div id="panel-field" class="floating-panel" style="top: 360px;">
                <div class="panel-header">
                    <span class="panel-title">Field Tools</span>
                    <button class="panel-close" data-panel="field">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn" id="btn-boundary"><img src="icons/Boundary.png">Boundary</button>
                        <button class="panel-btn"><img src="icons/HeadlandBuild.png">Headland</button>
                        <button class="panel-btn"><img src="icons/TramAll.png">Tram Lines</button>
                        <button class="panel-btn"><img src="icons/Headache.png">Headland Build</button>
                        <button class="panel-btn"><img src="icons/TrashApplied.png">Delete Applied</button>
                        <button class="panel-btn"><img src="icons/TramMulti.png">Tram Build</button>
                        <button class="panel-btn"><img src="icons/RecPath.png">Recorded Path</button>
                        <button class="panel-btn"><img src="icons/BoundaryFromTracks.png">Import Tracks</button>
                    </div>
                </div>
            </div>

            <!-- AutoSteer Panel -->
            <div id="panel-steer" class="floating-panel" style="top: 420px;">
                <div class="panel-header">
                    <span class="panel-title">AutoSteer</span>
                    <button class="panel-close" data-panel="steer">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn full-width"><img src="icons/AutoSteerConf.png">AutoSteer Config</button>
                        <button class="panel-btn"><img src="icons/AutoSteerOn.png">Steer Enable</button>
                        <button class="panel-btn"><img src="icons/AutoSteerOff.png">Steer Disable</button>
                    </div>
                </div>
            </div>

            <!-- AgIO Panel -->
            <div id="panel-agio" class="floating-panel" style="top: 480px;">
                <div class="panel-header">
                    <span class="panel-title">Data I/O</span>
                    <button class="panel-close" data-panel="agio">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn full-width"><img src="icons/AgIO.png">AgIO Connection</button>
                        <button class="panel-btn"><img src="icons/FileOpen.png">Import</button>
                        <button class="panel-btn"><img src="icons/AgShare.png">Export</button>
                    </div>
                </div>
            </div>

            <!-- Field List Modal (for Open Field) -->
            <div id="modal-backdrop" class="modal-backdrop"></div>
            <div id="field-list-modal" class="field-list-modal">
                <div class="panel-header">
                    <span class="panel-title">Open Field</span>
                    <button class="panel-close" id="field-list-close">&times;</button>
                </div>
                <div class="panel-content">
                    <div id="field-list" class="field-list">
                        <!-- Field items will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== WebGL Map Renderer =====
        const canvas = document.getElementById('map-canvas');
        const gl = canvas.getContext('webgl', {
            antialias: true,
            alpha: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false
        });

        // Enable line smoothing if available
        if (gl) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            // Try to set line width (limited support, but helps where available)
            gl.lineWidth(1.5);
        }

        if (!gl) {
            alert('WebGL not supported - falling back to Canvas2D');
        }

        // State
        let camera = { x: 0, y: 0, zoom: 1, rotation: 0 };
        let vehicle = { x: 0, y: 0, heading: 0 };
        let simulator = { enabled: false, speed: 0, steerAngle: 0, targetSpeedKmh: 0 };
        let boundary = [];
        let lastTime = 0;

        // Touch state
        let touches = {};
        let lastPinchDist = 0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // Resize handler
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resize);
        resize();

        // ===== Shaders =====
        const vertexShaderSrc = `
            precision highp float;
            attribute vec2 a_position;
            uniform mat3 u_matrix;
            void main() {
                vec3 pos = u_matrix * vec3(a_position, 1.0);
                gl_Position = vec4(pos.xy, 0.0, 1.0);
                gl_PointSize = 4.0;
            }
        `;

        const fragmentShaderSrc = `
            precision highp float;
            uniform vec4 u_color;
            void main() {
                gl_FragColor = u_color;
            }
        `;

        // Shader for thick anti-aliased lines (drawn as quads)
        const thickLineVertexSrc = `
            precision highp float;
            attribute vec2 a_position;
            attribute float a_edge; // 0.0 = center, 1.0 = edge (for AA)
            uniform mat3 u_matrix;
            varying float v_edge;
            void main() {
                vec3 pos = u_matrix * vec3(a_position, 1.0);
                gl_Position = vec4(pos.xy, 0.0, 1.0);
                v_edge = a_edge;
            }
        `;

        const thickLineFragmentSrc = `
            precision highp float;
            uniform vec4 u_color;
            varying float v_edge;
            void main() {
                // Smooth anti-aliasing at edges
                float alpha = u_color.a * (1.0 - smoothstep(0.5, 1.0, v_edge));
                gl_FragColor = vec4(u_color.rgb, alpha);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vs = createShader(gl.VERTEX_SHADER, vertexShaderSrc);
        const fs = createShader(gl.FRAGMENT_SHADER, fragmentShaderSrc);
        const program = createProgram(vs, fs);

        const a_position = gl.getAttribLocation(program, 'a_position');
        const u_matrix = gl.getUniformLocation(program, 'u_matrix');
        const u_color = gl.getUniformLocation(program, 'u_color');

        const positionBuffer = gl.createBuffer();

        // Thick line program
        const tlVs = createShader(gl.VERTEX_SHADER, thickLineVertexSrc);
        const tlFs = createShader(gl.FRAGMENT_SHADER, thickLineFragmentSrc);
        const thickLineProgram = createProgram(tlVs, tlFs);

        const tl_a_position = gl.getAttribLocation(thickLineProgram, 'a_position');
        const tl_a_edge = gl.getAttribLocation(thickLineProgram, 'a_edge');
        const tl_u_matrix = gl.getUniformLocation(thickLineProgram, 'u_matrix');
        const tl_u_color = gl.getUniformLocation(thickLineProgram, 'u_color');

        const thickLineBuffer = gl.createBuffer();
        const edgeBuffer = gl.createBuffer();

        // ===== Grid Texture Cache =====
        // Two modes:
        // 1. No boundary: repeating grid texture (REPEAT wrap)
        // 2. With boundary: field-sized texture with grid + boundary (CLAMP_TO_EDGE)
        const GRID_TEX_SIZE = 2048; // Texture size in pixels
        const GRID_WORLD_SIZE = 400; // World units for repeating grid (no boundary)

        // Field texture extents (set when boundary is loaded)
        let fieldExtents = null; // { minX, maxX, minY, maxY, width, height, centerX, centerY }

        // Create framebuffer for grid/field texture
        const gridTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, gridTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, GRID_TEX_SIZE, GRID_TEX_SIZE, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

        const gridFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, gridFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, gridTexture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // Texture shader for drawing the cached grid
        const texVertexSrc = `
            precision highp float;
            attribute vec2 a_position;
            attribute vec2 a_texcoord;
            varying vec2 v_texcoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texcoord = a_texcoord;
            }
        `;
        const texFragmentSrc = `
            precision highp float;
            uniform sampler2D u_texture;
            varying vec2 v_texcoord;
            void main() {
                gl_FragColor = texture2D(u_texture, v_texcoord);
            }
        `;

        const texVs = createShader(gl.VERTEX_SHADER, texVertexSrc);
        const texFs = createShader(gl.FRAGMENT_SHADER, texFragmentSrc);
        const texProgram = createProgram(texVs, texFs);
        const tex_a_position = gl.getAttribLocation(texProgram, 'a_position');
        const tex_a_texcoord = gl.getAttribLocation(texProgram, 'a_texcoord');
        const tex_u_texture = gl.getUniformLocation(texProgram, 'u_texture');

        const quadBuffer = gl.createBuffer();
        const texcoordBuffer = gl.createBuffer();

        // Fullscreen quad vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        let gridTextureValid = false;

        // Sprite shader for rotated textured quads (tractor)
        const spriteVertexSrc = `
            precision highp float;
            attribute vec2 a_position;
            attribute vec2 a_texcoord;
            uniform mat3 u_matrix;
            varying vec2 v_texcoord;
            void main() {
                vec3 pos = u_matrix * vec3(a_position, 1.0);
                gl_Position = vec4(pos.xy, 0.0, 1.0);
                v_texcoord = a_texcoord;
            }
        `;
        const spriteFragmentSrc = `
            precision highp float;
            uniform sampler2D u_texture;
            varying vec2 v_texcoord;
            void main() {
                gl_FragColor = texture2D(u_texture, v_texcoord);
            }
        `;

        const spriteVs = createShader(gl.VERTEX_SHADER, spriteVertexSrc);
        const spriteFs = createShader(gl.FRAGMENT_SHADER, spriteFragmentSrc);
        const spriteProgram = createProgram(spriteVs, spriteFs);
        const sprite_a_position = gl.getAttribLocation(spriteProgram, 'a_position');
        const sprite_a_texcoord = gl.getAttribLocation(spriteProgram, 'a_texcoord');
        const sprite_u_matrix = gl.getUniformLocation(spriteProgram, 'u_matrix');
        const sprite_u_texture = gl.getUniformLocation(spriteProgram, 'u_texture');

        const spriteBuffer = gl.createBuffer();
        const spriteTexcoordBuffer = gl.createBuffer();

        // Load tractor texture
        let tractorTexture = null;
        let tractorTextureLoaded = false;
        const tractorImage = new Image();
        tractorImage.onload = function() {
            tractorTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tractorTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tractorImage);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            tractorTextureLoaded = true;
            console.log('Tractor texture loaded');
        };
        tractorImage.src = 'icons/TractorAoG.png';

        function renderGridToTexture() {
            // Determine world size and center based on whether we have a boundary
            let worldSize, centerX, centerY;

            if (fieldExtents) {
                // Field mode: texture covers the field extents
                worldSize = fieldExtents.size;
                centerX = fieldExtents.centerX;
                centerY = fieldExtents.centerY;
                // Switch to CLAMP mode for field texture
                gl.bindTexture(gl.TEXTURE_2D, gridTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            } else {
                // No boundary: repeating grid pattern
                worldSize = GRID_WORLD_SIZE;
                centerX = 0;
                centerY = 0;
                // Use REPEAT mode for infinite grid
                gl.bindTexture(gl.TEXTURE_2D, gridTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, gridFramebuffer);
            gl.viewport(0, 0, GRID_TEX_SIZE, GRID_TEX_SIZE);
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            // Set up matrix for texture rendering
            const texScale = 2 / worldSize;
            gl.uniformMatrix3fv(u_matrix, false, new Float32Array([
                texScale, 0, 0,
                0, texScale, 0,
                -centerX * texScale, -centerY * texScale, 1
            ]));

            const majorSpacing = 100;
            const halfSize = worldSize / 2;

            // Grid extents in world coords
            const minX = centerX - halfSize;
            const maxX = centerX + halfSize;
            const minY = centerY - halfSize;
            const maxY = centerY + halfSize;

            // Major grid lines only (100m spacing) - draw as thick quads for stability
            const majorLineWidth = worldSize / GRID_TEX_SIZE * 2.5;
            let majorQuads = [];

            const majorMinX = Math.floor(minX / majorSpacing) * majorSpacing;
            const majorMaxX = Math.ceil(maxX / majorSpacing) * majorSpacing;
            const majorMinY = Math.floor(minY / majorSpacing) * majorSpacing;
            const majorMaxY = Math.ceil(maxY / majorSpacing) * majorSpacing;

            for (let x = majorMinX; x <= majorMaxX; x += majorSpacing) {
                majorQuads.push(
                    x - majorLineWidth/2, minY,
                    x + majorLineWidth/2, minY,
                    x + majorLineWidth/2, maxY,
                    x - majorLineWidth/2, minY,
                    x + majorLineWidth/2, maxY,
                    x - majorLineWidth/2, maxY
                );
            }
            for (let y = majorMinY; y <= majorMaxY; y += majorSpacing) {
                majorQuads.push(
                    minX, y - majorLineWidth/2,
                    maxX, y - majorLineWidth/2,
                    maxX, y + majorLineWidth/2,
                    minX, y - majorLineWidth/2,
                    maxX, y + majorLineWidth/2,
                    minX, y + majorLineWidth/2
                );
            }
            if (majorQuads.length > 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(majorQuads), gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(a_position);
                gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
                gl.uniform4fv(u_color, [0.45, 0.45, 0.45, 1.0]);
                gl.drawArrays(gl.TRIANGLES, 0, majorQuads.length / 2);
            }

            // Draw boundary into texture (if we have one)
            if (boundary.length >= 4) {
                const boundaryLineWidth = worldSize / GRID_TEX_SIZE * 3;
                let boundaryQuads = [];
                for (let i = 0; i < boundary.length; i += 4) {
                    const x1 = boundary[i], y1 = boundary[i+1];
                    const x2 = boundary[i+2], y2 = boundary[i+3];

                    const dx = x2 - x1, dy = y2 - y1;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    if (len === 0) continue;
                    const px = -dy/len * boundaryLineWidth/2;
                    const py = dx/len * boundaryLineWidth/2;

                    boundaryQuads.push(
                        x1+px, y1+py, x1-px, y1-py, x2+px, y2+py,
                        x1-px, y1-py, x2-px, y2-py, x2+px, y2+py
                    );
                }
                if (boundaryQuads.length > 0) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(boundaryQuads), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(a_position);
                    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
                    gl.uniform4fv(u_color, [1.0, 1.0, 0.0, 1.0]); // Yellow
                    gl.drawArrays(gl.TRIANGLES, 0, boundaryQuads.length / 2);
                }
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);

            // Generate mipmaps for smooth filtering
            gl.bindTexture(gl.TEXTURE_2D, gridTexture);
            gl.generateMipmap(gl.TEXTURE_2D);

            gridTextureValid = true;
        }

        function drawCachedGrid() {
            if (!gridTextureValid) {
                renderGridToTexture();
            }

            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;

            let left, right, bottom, top;

            if (fieldExtents) {
                // Field mode: texture is in world coords, use camera position to calculate UV
                // The texture covers fieldExtents.size centered at fieldExtents.center
                const worldSize = fieldExtents.size;
                const centerX = fieldExtents.centerX;
                const centerY = fieldExtents.centerY;

                // Convert camera view to texture coords (0-1 range)
                // Texture left edge = centerX - worldSize/2, right = centerX + worldSize/2
                const texMinX = centerX - worldSize / 2;
                const texMinY = centerY - worldSize / 2;

                // Camera view in world coords
                const viewLeft = camera.x - viewWidth / 2;
                const viewRight = camera.x + viewWidth / 2;
                const viewBottom = camera.y - viewHeight / 2;
                const viewTop = camera.y + viewHeight / 2;

                // Convert to texture coords (0-1)
                left = (viewLeft - texMinX) / worldSize;
                right = (viewRight - texMinX) / worldSize;
                bottom = (viewBottom - texMinY) / worldSize;
                top = (viewTop - texMinY) / worldSize;
            } else {
                // No boundary: repeating grid pattern
                const texOffsetX = camera.x / GRID_WORLD_SIZE;
                const texOffsetY = camera.y / GRID_WORLD_SIZE;
                const texScaleX = viewWidth / GRID_WORLD_SIZE;
                const texScaleY = viewHeight / GRID_WORLD_SIZE;

                left = texOffsetX - texScaleX / 2;
                right = texOffsetX + texScaleX / 2;
                bottom = texOffsetY - texScaleY / 2;
                top = texOffsetY + texScaleY / 2;
            }

            gl.useProgram(texProgram);

            // Quad vertices (fullscreen)
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(tex_a_position);
            gl.vertexAttribPointer(tex_a_position, 2, gl.FLOAT, false, 0, 0);

            // Texcoords
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                left, bottom, right, bottom, left, top,
                left, top, right, bottom, right, top
            ]), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tex_a_texcoord);
            gl.vertexAttribPointer(tex_a_texcoord, 2, gl.FLOAT, false, 0, 0);

            // Bind texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, gridTexture);
            gl.uniform1i(tex_u_texture, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Switch back to main program
            gl.useProgram(program);
        }

        function drawBoundary() {
            if (boundary.length < 4) return;
            drawLines(boundary, [1, 1, 0, 1]); // Yellow
        }

        // ===== Transform Matrix (for screen-space rendering) =====
        function getMatrix() {
            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;

            // Scale to clip space
            const sx = 2 / viewWidth;
            const sy = 2 / viewHeight;

            // Translation (camera centered)
            const tx = -camera.x;
            const ty = -camera.y;

            // Rotation
            const cos = Math.cos(-camera.rotation);
            const sin = Math.sin(-camera.rotation);

            // Combined matrix: scale * rotate * translate
            return new Float32Array([
                sx * cos, sx * sin, 0,
                -sy * sin, sy * cos, 0,
                (tx * cos - ty * sin) * sx, (tx * sin + ty * cos) * sy, 1
            ]);
        }

        // For vehicle smoothing only
        let smoothCamX = 0;
        let smoothCamY = 0;

        // ===== Drawing Functions =====
        function drawLines(vertices, color, mode = gl.LINES) {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(u_color, color);
            gl.drawArrays(mode, 0, vertices.length / 2);
        }

        // Draw thick anti-aliased lines as quads
        // lineWidth is in world units (meters)
        function drawThickLines(lineSegments, color, lineWidth = 0.5) {
            if (lineSegments.length < 4) return;

            // Each line segment (x1,y1,x2,y2) becomes 2 triangles (6 vertices)
            const positions = [];
            const edges = [];

            for (let i = 0; i < lineSegments.length; i += 4) {
                const x1 = lineSegments[i];
                const y1 = lineSegments[i + 1];
                const x2 = lineSegments[i + 2];
                const y2 = lineSegments[i + 3];

                // Calculate perpendicular direction
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) continue;

                // Perpendicular unit vector
                const px = -dy / len;
                const py = dx / len;

                // Half width offset
                const hw = lineWidth / 2;

                // 4 corners of the quad
                const ax = x1 + px * hw, ay = y1 + py * hw;
                const bx = x1 - px * hw, by = y1 - py * hw;
                const cx = x2 + px * hw, cy = y2 + py * hw;
                const dx2 = x2 - px * hw, dy2 = y2 - py * hw;

                // Two triangles (6 vertices)
                // Triangle 1: a, b, c
                positions.push(ax, ay, bx, by, cx, cy);
                edges.push(1, 1, 0); // edges at corners, center in middle

                // Triangle 2: b, d, c
                positions.push(bx, by, dx2, dy2, cx, cy);
                edges.push(1, 1, 0);
            }

            if (positions.length === 0) return;

            gl.useProgram(thickLineProgram);
            gl.uniformMatrix3fv(tl_u_matrix, false, getMatrix());
            gl.uniform4fv(tl_u_color, color);

            // Position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, thickLineBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tl_a_position);
            gl.vertexAttribPointer(tl_a_position, 2, gl.FLOAT, false, 0, 0);

            // Edge buffer (for AA)
            gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(edges), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tl_a_edge);
            gl.vertexAttribPointer(tl_a_edge, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);

            // Switch back to simple program
            gl.useProgram(program);
            gl.disableVertexAttribArray(tl_a_edge);
        }

        function drawGrid() {
            // AOG-style grid: 20m minor, 100m major
            const spacing = 20;
            const majorSpacing = 100;
            const viewRange = 250;

            // Use integer grid positions to avoid floating point issues
            const camXGrid = Math.round(camera.x / spacing) * spacing;
            const camYGrid = Math.round(camera.y / spacing) * spacing;

            // Calculate visible grid range centered on snapped camera
            const minX = camXGrid - viewRange;
            const maxX = camXGrid + viewRange;
            const minY = camYGrid - viewRange;
            const maxY = camYGrid + viewRange;

            // Minor grid lines (use exact integer positions)
            let minorLines = [];
            for (let x = minX; x <= maxX; x += spacing) {
                if (x % majorSpacing !== 0) {
                    minorLines.push(x, minY, x, maxY);
                }
            }
            for (let y = minY; y <= maxY; y += spacing) {
                if (y % majorSpacing !== 0) {
                    minorLines.push(minX, y, maxX, y);
                }
            }
            if (minorLines.length > 0) {
                drawLines(minorLines, [0.28, 0.28, 0.28, 1.0]);
            }

            // Major grid lines
            const majorMinX = Math.floor(minX / majorSpacing) * majorSpacing;
            const majorMaxX = Math.ceil(maxX / majorSpacing) * majorSpacing;
            const majorMinY = Math.floor(minY / majorSpacing) * majorSpacing;
            const majorMaxY = Math.ceil(maxY / majorSpacing) * majorSpacing;

            let majorLines = [];
            for (let x = majorMinX; x <= majorMaxX; x += majorSpacing) {
                majorLines.push(x, majorMinY, x, majorMaxY);
            }
            for (let y = majorMinY; y <= majorMaxY; y += majorSpacing) {
                majorLines.push(majorMinX, y, majorMaxX, y);
            }
            if (majorLines.length > 0) {
                drawLines(majorLines, [0.45, 0.45, 0.45, 1.0]);
            }

            // Axes (at world origin)
            if (minY <= 0 && maxY >= 0) {
                drawLines([minX, 0, maxX, 0], [0.8, 0.2, 0.2, 1]);
            }
            if (minX <= 0 && maxX >= 0) {
                drawLines([0, minY, 0, maxY], [0.2, 0.8, 0.2, 1]);
            }
        }

        // Smoothed values for stable rendering
        let smoothedHeading = 0;
        let lastHeading = 0;
        let headingVelocity = 0; // radians per second
        let lastHeadingTime = 0;

        function drawVehicleScreenSpace() {
            const now = performance.now();
            const dt = lastHeadingTime > 0 ? (now - lastHeadingTime) / 1000 : 0.016;
            lastHeadingTime = now;

            // Detect heading changes and calculate angular velocity
            let headingDelta = vehicle.heading - lastHeading;
            if (headingDelta > Math.PI) headingDelta -= 2 * Math.PI;
            if (headingDelta < -Math.PI) headingDelta += 2 * Math.PI;

            if (Math.abs(headingDelta) > 0.001) {
                // New heading received - update velocity estimate
                headingVelocity = headingDelta / 0.1; // Assume 10Hz updates
                lastHeading = vehicle.heading;
            }

            // Predict heading based on velocity (interpolate between updates)
            let targetHeading = smoothedHeading + headingVelocity * dt;

            // Also blend toward actual heading to prevent drift
            let errorToActual = vehicle.heading - targetHeading;
            if (errorToActual > Math.PI) errorToActual -= 2 * Math.PI;
            if (errorToActual < -Math.PI) errorToActual += 2 * Math.PI;
            targetHeading += errorToActual * 0.1;

            // Smooth toward target
            let delta = targetHeading - smoothedHeading;
            if (delta > Math.PI) delta -= 2 * Math.PI;
            if (delta < -Math.PI) delta += 2 * Math.PI;
            smoothedHeading += delta * 0.3;

            // Get aspect and view dimensions to convert to clip space
            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;
            const sx = 2 / viewWidth;
            const sy = 2 / viewHeight;

            // Draw tractor sprite if texture is loaded, otherwise fallback to triangle
            if (tractorTextureLoaded && tractorTexture) {
                // Size of tractor in world units
                const size = 8;
                const halfW = size * 0.5 * sx;
                const halfH = size * 0.5 * sy;

                // Build rotation matrix (rotate around center)
                // Negate heading for clockwise rotation (right turn = positive heading)
                const cos = Math.cos(-smoothedHeading);
                const sin = Math.sin(-smoothedHeading);

                // Rotation matrix in column-major order for WebGL
                // Rotate then scale
                const matrix = new Float32Array([
                    cos * halfW, sin * halfW, 0,
                    -sin * halfH, cos * halfH, 0,
                    0, 0, 1
                ]);

                gl.useProgram(spriteProgram);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                // Quad vertices (unit square centered at origin)
                gl.bindBuffer(gl.ARRAY_BUFFER, spriteBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1, 1, -1, -1, 1,
                    -1, 1, 1, -1, 1, 1
                ]), gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(sprite_a_position);
                gl.vertexAttribPointer(sprite_a_position, 2, gl.FLOAT, false, 0, 0);

                // Texcoords (flip Y for correct orientation)
                gl.bindBuffer(gl.ARRAY_BUFFER, spriteTexcoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    0, 1, 1, 1, 0, 0,
                    0, 0, 1, 1, 1, 0
                ]), gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(sprite_a_texcoord);
                gl.vertexAttribPointer(sprite_a_texcoord, 2, gl.FLOAT, false, 0, 0);

                gl.uniformMatrix3fv(sprite_u_matrix, false, matrix);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tractorTexture);
                gl.uniform1i(sprite_u_texture, 0);

                gl.drawArrays(gl.TRIANGLES, 0, 6);

                gl.disable(gl.BLEND);
                gl.useProgram(program);
            } else {
                // Fallback: draw green triangle
                const size = 6;
                const cos = Math.cos(smoothedHeading);
                const sin = Math.sin(smoothedHeading);
                const frontDist = size;
                const backDist = size * 0.5;
                const sideDist = size * 0.4;

                const tipX = sin * frontDist * sx;
                const tipY = cos * frontDist * sy;
                const leftX = (-cos * sideDist - sin * backDist) * sx;
                const leftY = (sin * sideDist - cos * backDist) * sy;
                const rightX = (cos * sideDist - sin * backDist) * sx;
                const rightY = (-sin * sideDist - cos * backDist) * sy;

                gl.uniformMatrix3fv(u_matrix, false, new Float32Array([1,0,0, 0,1,0, 0,0,1]));
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    tipX, tipY, leftX, leftY, rightX, rightY
                ]), gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(a_position);
                gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
                gl.uniform4fv(u_color, [0.2, 0.85, 0.2, 1.0]);
                gl.drawArrays(gl.TRIANGLES, 0, 3);
            }

            // Restore world matrix
            gl.uniformMatrix3fv(u_matrix, false, getMatrix());
        }

        function drawVehicle() {
            const size = 5;
            const cos = Math.cos(vehicle.heading);
            const sin = Math.sin(vehicle.heading);

            // Draw vehicle at camera position (center of view)
            const cx = camera.x;
            const cy = camera.y;

            // Triangle pointing in heading direction
            const tip = [cx + sin * size, cy + cos * size];
            const left = [cx - cos * size/3 - sin * size/2, cy + sin * size/3 - cos * size/2];
            const right = [cx + cos * size/3 - sin * size/2, cy - sin * size/3 - cos * size/2];

            drawLines([
                tip[0], tip[1], left[0], left[1],
                left[0], left[1], right[0], right[1],
                right[0], right[1], tip[0], tip[1]
            ], [0.2, 1, 0.2, 1]); // Lime green
        }

        // ===== Main Render Loop =====
        function render(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            // Update simulator
            if (simulator.enabled) {
                updateSimulator(dt);
            }

            // Camera follows vehicle
            camera.x = vehicle.x;
            camera.y = vehicle.y;

            // Clear
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Draw cached grid (texture-based, no shimmer)
            // When a boundary is loaded, it's also baked into this texture
            drawCachedGrid();

            // Draw vehicle on top (screen-space, always stable)
            drawVehicleScreenSpace();

            // Update UI
            updateUI();

            requestAnimationFrame(render);
        }

        // ===== Simulator =====
        function updateSimulator(dt) {
            // Update heading based on steer angle and speed
            const turnRate = simulator.steerAngle * 0.5 * (simulator.speed / 10);
            vehicle.heading += turnRate * dt;

            // Update position based on heading and speed
            vehicle.x += Math.sin(vehicle.heading) * simulator.speed * dt;
            vehicle.y += Math.cos(vehicle.heading) * simulator.speed * dt;
        }

        // ===== UI Updates =====
        function updateUI() {
            document.getElementById('speed-value').textContent = (simulator.speed * 3.6).toFixed(1);
            document.getElementById('heading-value').textContent = ((vehicle.heading * 180 / Math.PI) % 360).toFixed(0);
            document.getElementById('easting-value').textContent = vehicle.x.toFixed(1);
            document.getElementById('northing-value').textContent = vehicle.y.toFixed(1);
        }

        // ===== Touch/Mouse Handlers =====
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let t of e.changedTouches) {
                touches[t.identifier] = { x: t.clientX, y: t.clientY };
            }
            if (Object.keys(touches).length === 1) {
                isPanning = true;
                const t = e.touches[0];
                panStart = { x: t.clientX, y: t.clientY };
            } else if (Object.keys(touches).length === 2) {
                const [t1, t2] = e.touches;
                lastPinchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                // Pinch zoom
                const [t1, t2] = e.touches;
                const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                if (lastPinchDist > 0) {
                    camera.zoom *= dist / lastPinchDist;
                    camera.zoom = Math.max(0.1, Math.min(50, camera.zoom));
                }
                lastPinchDist = dist;
            }
            // Note: Pan disabled while simulator camera follows vehicle
        });

        canvas.addEventListener('touchend', (e) => {
            for (let t of e.changedTouches) {
                delete touches[t.identifier];
            }
            if (Object.keys(touches).length < 2) {
                lastPinchDist = 0;
            }
            isPanning = false;
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom *= factor;
            camera.zoom = Math.max(0.1, Math.min(50, camera.zoom));
        });

        // ===== Button Handlers =====
        document.getElementById('zoom-in').addEventListener('click', () => {
            camera.zoom *= 1.2;
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            camera.zoom *= 0.8;
        });

        // ===== WebSocket Connection =====
        let ws = null;
        let wsConnected = false;

        function connectWebSocket() {
            const wsUrl = `ws://${window.location.host}/ws`;
            console.log('Connecting to WebSocket:', wsUrl);

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                wsConnected = true;
                document.getElementById('gps-dot').style.background = '#1ABC9C';
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                wsConnected = false;
                document.getElementById('gps-dot').style.background = '#E74C3C';
                // Reconnect after 2 seconds
                setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);

                if (msg.type === 'gps') {
                    // Update vehicle from server GPS data
                    vehicle.x = msg.data.easting;
                    vehicle.y = msg.data.northing;
                    vehicle.heading = msg.data.heading * Math.PI / 180; // degrees to radians
                    simulator.speed = msg.data.speed / 3.6; // km/h to m/s
                }
                else if (msg.type === 'connected') {
                    console.log('Connected to server, ID:', msg.connectionId);
                    if (msg.simulator) {
                        simulator.enabled = msg.simulator.running;
                        simulator.speed = msg.simulator.speed / 3.6; // km/h to m/s
                        simulator.steerAngle = msg.simulator.steerAngle;
                        // UI update will happen after updateSimulatorUI is defined
                    }
                    // Check for active field on connect
                    if (msg.field && msg.field.isOpen) {
                        activeField = msg.field.name;
                        // updateFieldDisplay will be called later when function is defined
                    }
                }
                else if (msg.type === 'simulator') {
                    console.log('Simulator message:', msg);
                }
                else if (msg.type === 'field') {
                    handleFieldMessage(msg);
                }
            };
        }

        function sendWsMessage(msg) {
            if (ws && wsConnected) {
                ws.send(JSON.stringify(msg));
            }
        }

        // Simulator control handlers are set up after panel management section

        // Connect to WebSocket on load
        connectWebSocket();

        // ===== Panel Management =====
        const panels = {
            file: document.getElementById('panel-file'),
            view: document.getElementById('panel-view'),
            tools: document.getElementById('panel-tools'),
            config: document.getElementById('panel-config'),
            job: document.getElementById('panel-job'),
            field: document.getElementById('panel-field'),
            steer: document.getElementById('panel-steer'),
            agio: document.getElementById('panel-agio')
        };

        const navButtons = {
            file: document.getElementById('btn-file'),
            view: document.getElementById('btn-view'),
            tools: document.getElementById('btn-tools'),
            config: document.getElementById('btn-config'),
            job: document.getElementById('btn-job'),
            field: document.getElementById('btn-field'),
            steer: document.getElementById('btn-steer'),
            agio: document.getElementById('btn-agio')
        };

        let activePanel = null;

        function togglePanel(panelName) {
            // If clicking the same panel, close it
            if (activePanel === panelName) {
                panels[panelName].classList.remove('visible');
                navButtons[panelName].classList.remove('active');
                activePanel = null;
                return;
            }

            // Close currently open panel
            if (activePanel) {
                panels[activePanel].classList.remove('visible');
                navButtons[activePanel].classList.remove('active');
            }

            // Open new panel
            panels[panelName].classList.add('visible');
            navButtons[panelName].classList.add('active');
            activePanel = panelName;
        }

        function closePanel(panelName) {
            panels[panelName].classList.remove('visible');
            navButtons[panelName].classList.remove('active');
            if (activePanel === panelName) {
                activePanel = null;
            }
        }

        // Wire up nav buttons
        Object.keys(navButtons).forEach(name => {
            navButtons[name].addEventListener('click', () => togglePanel(name));
        });

        // Wire up close buttons
        document.querySelectorAll('.panel-close').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const panelName = e.target.dataset.panel;
                closePanel(panelName);
            });
        });

        // Close panel when clicking outside
        document.getElementById('map-container').addEventListener('click', (e) => {
            // Only close if clicking directly on map-container or canvas
            if (e.target.id === 'map-container' || e.target.id === 'map-canvas') {
                if (activePanel) {
                    closePanel(activePanel);
                }
            }
        });

        // Make panels draggable
        document.querySelectorAll('.panel-header').forEach(header => {
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            const panel = header.parentElement;

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('panel-close')) return;
                isDragging = true;
                const rect = panel.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const containerRect = document.getElementById('map-container').getBoundingClientRect();
                let newX = e.clientX - containerRect.left - dragOffset.x;
                let newY = e.clientY - containerRect.top - dragOffset.y;
                // Keep within bounds
                newX = Math.max(0, Math.min(containerRect.width - panel.offsetWidth, newX));
                newY = Math.max(0, Math.min(containerRect.height - panel.offsetHeight, newY));
                panel.style.left = newX + 'px';
                panel.style.top = newY + 'px';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch support for dragging
            header.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('panel-close')) return;
                isDragging = true;
                const touch = e.touches[0];
                const rect = panel.getBoundingClientRect();
                dragOffset.x = touch.clientX - rect.left;
                dragOffset.y = touch.clientY - rect.top;
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const containerRect = document.getElementById('map-container').getBoundingClientRect();
                let newX = touch.clientX - containerRect.left - dragOffset.x;
                let newY = touch.clientY - containerRect.top - dragOffset.y;
                newX = Math.max(0, Math.min(containerRect.width - panel.offsetWidth, newX));
                newY = Math.max(0, Math.min(containerRect.height - panel.offsetHeight, newY));
                panel.style.left = newX + 'px';
                panel.style.top = newY + 'px';
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        });

        // ===== Simulator Panel =====
        const simulatorPanel = document.getElementById('panel-simulator');
        let simulatorPanelVisible = false;

        function toggleSimulatorPanel() {
            simulatorPanelVisible = !simulatorPanelVisible;
            simulatorPanel.classList.toggle('visible', simulatorPanelVisible);
            // Update menu button state
            document.getElementById('panel-sim-btn').classList.toggle('active', simulatorPanelVisible);
        }

        function updateSimulatorUI() {
            const simToggle = document.getElementById('sim-toggle');
            simToggle.textContent = simulator.enabled ? 'Stop' : 'Start';
            simToggle.classList.toggle('active', simulator.enabled);

            // Update speed display - use targetSpeedKmh (not actual speed from GPS which can have timing drift)
            document.getElementById('sim-speed-display').textContent = simulator.targetSpeedKmh.toFixed(0) + ' km/h';

            // Update steering angle display
            document.getElementById('sim-steer-display').textContent = simulator.steerAngle.toFixed(0) + '°';

            // Update steer bar position (steerAngle is -45 to 45)
            const steerPercent = 50 + (simulator.steerAngle / 45) * 40; // 10% to 90%
            document.getElementById('steer-bar').style.left = steerPercent + '%';
        }

        // File Menu > Simulator button - opens/closes the simulator panel
        document.getElementById('panel-sim-btn').addEventListener('click', () => {
            closePanel('file');
            toggleSimulatorPanel();
        });

        // Simulator panel close button
        simulatorPanel.querySelector('.panel-close').addEventListener('click', () => {
            simulatorPanelVisible = false;
            simulatorPanel.classList.remove('visible');
            document.getElementById('panel-sim-btn').classList.remove('active');
        });

        // Start/Stop button in simulator panel
        document.getElementById('sim-toggle').addEventListener('click', () => {
            simulator.enabled = !simulator.enabled;
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: simulator.enabled ? 'start' : 'stop' });
        });

        // Speed controls - 2 km/h increments, negative for reverse
        document.getElementById('accel').addEventListener('click', () => {
            simulator.targetSpeedKmh = Math.min(25, simulator.targetSpeedKmh + 2);
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: simulator.targetSpeedKmh });
        });

        document.getElementById('decel').addEventListener('click', () => {
            simulator.targetSpeedKmh = Math.max(-10, simulator.targetSpeedKmh - 2);
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: simulator.targetSpeedKmh });
        });

        // Reset button
        document.getElementById('stop').addEventListener('click', () => {
            simulator.targetSpeedKmh = 0;
            simulator.speed = 0;
            simulator.steerAngle = 0;
            simulator.enabled = false;
            vehicle.x = 0;
            vehicle.y = 0;
            vehicle.heading = 0;
            // Reset all heading smoothing/prediction state
            smoothedHeading = 0;
            lastHeading = 0;
            headingVelocity = 0;
            lastHeadingTime = 0;
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'stop' });
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: 0 });
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: 0 });
            sendWsMessage({ type: 'simulator', action: 'setPosition', latitude: 40.7128, longitude: -74.0060 });
        });

        // Steering controls - 1 degree increments, +/-45 range
        document.getElementById('steer-left').addEventListener('click', () => {
            simulator.steerAngle = Math.max(-45, simulator.steerAngle - 1);
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: simulator.steerAngle });
        });

        document.getElementById('steer-right').addEventListener('click', () => {
            simulator.steerAngle = Math.min(45, simulator.steerAngle + 1);
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: simulator.steerAngle });
        });

        document.getElementById('steer-zero').addEventListener('click', () => {
            simulator.steerAngle = 0;
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: 0 });
        });

        // Make simulator panel draggable
        (function() {
            const header = simulatorPanel.querySelector('.panel-header');
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('panel-close')) return;
                isDragging = true;
                const rect = simulatorPanel.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const containerRect = document.getElementById('map-container').getBoundingClientRect();
                let newX = e.clientX - containerRect.left - dragOffset.x;
                let newY = e.clientY - containerRect.top - dragOffset.y;
                newX = Math.max(0, Math.min(containerRect.width - simulatorPanel.offsetWidth, newX));
                newY = Math.max(0, Math.min(containerRect.height - simulatorPanel.offsetHeight, newY));
                simulatorPanel.style.left = newX + 'px';
                simulatorPanel.style.top = newY + 'px';
                simulatorPanel.style.bottom = 'auto';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch support
            header.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('panel-close')) return;
                isDragging = true;
                const touch = e.touches[0];
                const rect = simulatorPanel.getBoundingClientRect();
                dragOffset.x = touch.clientX - rect.left;
                dragOffset.y = touch.clientY - rect.top;
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const containerRect = document.getElementById('map-container').getBoundingClientRect();
                let newX = touch.clientX - containerRect.left - dragOffset.x;
                let newY = touch.clientY - containerRect.top - dragOffset.y;
                newX = Math.max(0, Math.min(containerRect.width - simulatorPanel.offsetWidth, newX));
                newY = Math.max(0, Math.min(containerRect.height - simulatorPanel.offsetHeight, newY));
                simulatorPanel.style.left = newX + 'px';
                simulatorPanel.style.top = newY + 'px';
                simulatorPanel.style.bottom = 'auto';
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        })();

        // ===== Job Menu / Field Management =====
        let activeField = null;

        function updateFieldDisplay() {
            const display = document.getElementById('current-field-display');
            const nameSpan = document.getElementById('current-field-name');

            if (activeField) {
                display.style.display = 'block';
                display.classList.remove('no-field');
                nameSpan.textContent = activeField;
            } else {
                display.style.display = 'none';
            }
        }

        function showFieldListModal(fields) {
            const modal = document.getElementById('field-list-modal');
            const backdrop = document.getElementById('modal-backdrop');
            const list = document.getElementById('field-list');

            list.innerHTML = '';

            if (fields.length === 0) {
                list.innerHTML = '<div class="field-list-empty">No fields found</div>';
            } else {
                fields.forEach(fieldName => {
                    const item = document.createElement('div');
                    item.className = 'field-list-item';
                    item.textContent = fieldName;
                    item.addEventListener('click', () => {
                        openField(fieldName);
                        hideFieldListModal();
                    });
                    list.appendChild(item);
                });
            }

            modal.classList.add('visible');
            backdrop.classList.add('visible');
        }

        function hideFieldListModal() {
            document.getElementById('field-list-modal').classList.remove('visible');
            document.getElementById('modal-backdrop').classList.remove('visible');
        }

        function openField(fieldName) {
            sendWsMessage({ type: 'field', action: 'open', name: fieldName });
        }

        function closeField() {
            sendWsMessage({ type: 'field', action: 'close' });
        }

        function createNewField() {
            const name = prompt('Enter new field name:');
            if (name && name.trim()) {
                sendWsMessage({ type: 'field', action: 'create', name: name.trim() });
            }
        }

        function requestFieldList() {
            sendWsMessage({ type: 'field', action: 'list' });
        }

        // Field list modal close handlers
        document.getElementById('field-list-close').addEventListener('click', hideFieldListModal);
        document.getElementById('modal-backdrop').addEventListener('click', hideFieldListModal);

        // Job Menu button handlers
        document.getElementById('job-open').addEventListener('click', () => {
            closePanel('job');
            requestFieldList();
        });

        document.getElementById('job-close').addEventListener('click', () => {
            closePanel('job');
            closeField();
        });

        document.getElementById('job-new').addEventListener('click', () => {
            closePanel('job');
            createNewField();
        });

        // Placeholder handlers for unimplemented features
        document.getElementById('job-isoxml').addEventListener('click', () => {
            alert('ISO-XML import not yet implemented');
        });

        document.getElementById('job-kml').addEventListener('click', () => {
            alert('KML import not yet implemented');
        });

        document.getElementById('job-drivein').addEventListener('click', () => {
            closePanel('job');
            // Send current GPS position to find nearest field
            sendWsMessage({
                type: 'field',
                action: 'findNearest',
                latitude: gpsState.latitude,
                longitude: gpsState.longitude
            });
        });

        document.getElementById('job-existing').addEventListener('click', () => {
            alert('From Existing not yet implemented');
        });

        document.getElementById('job-resume').addEventListener('click', () => {
            alert('Resume not yet implemented');
        });

        // Handle field-related WebSocket messages
        function handleFieldMessage(msg) {
            console.log('Field message:', msg);

            switch (msg.action) {
                case 'list':
                    showFieldListModal(msg.fields || []);
                    break;
                case 'opened':
                case 'created':
                    activeField = msg.name;
                    updateFieldDisplay();
                    if (msg.boundary) {
                        setBoundary(msg.boundary);
                    } else {
                        clearBoundary();
                    }
                    // Move simulator to field origin if provided
                    if (msg.origin && msg.origin.latitude && msg.origin.longitude) {
                        console.log('Moving simulator to field origin:', msg.origin);
                        sendWsMessage({ type: 'simulator', action: 'setPosition', latitude: msg.origin.latitude, longitude: msg.origin.longitude });
                    }
                    break;
                case 'closed':
                    activeField = null;
                    updateFieldDisplay();
                    clearBoundary();
                    break;
                case 'changed':
                    activeField = msg.isOpen ? msg.name : null;
                    updateFieldDisplay();
                    if (msg.boundary) {
                        setBoundary(msg.boundary);
                    } else if (!msg.isOpen) {
                        clearBoundary();
                    }
                    break;
                case 'active':
                    activeField = msg.isOpen ? msg.name : null;
                    updateFieldDisplay();
                    break;
                case 'error':
                    alert('Field error: ' + msg.message);
                    break;
                case 'foundNearest':
                    if (msg.success) {
                        // Field was found and opened
                        activeField = msg.name;
                        updateFieldDisplay();
                        if (msg.boundary) {
                            setBoundary(msg.boundary);
                        } else {
                            clearBoundary();
                        }
                        console.log(`Drive-In: Found field "${msg.name}" at ${msg.distance.toFixed(2)}km`);
                    } else {
                        // No field found nearby
                        alert(msg.message || 'No field found near current position');
                    }
                    break;
            }
        }

        // Boundary storage and rendering
        let fieldBoundary = null; // { outer: [{e, n}, ...], inner: [[{e, n}, ...], ...] }

        function setBoundary(boundaryData) {
            fieldBoundary = boundaryData;
            console.log('Boundary set:', fieldBoundary);

            // Convert to line segments for rendering
            if (fieldBoundary && fieldBoundary.outer && fieldBoundary.outer.length > 0) {
                boundary = [];
                const pts = fieldBoundary.outer;

                // Calculate field extents from boundary
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                for (let i = 0; i < pts.length; i++) {
                    const next = (i + 1) % pts.length;
                    boundary.push(pts[i].e, pts[i].n, pts[next].e, pts[next].n);

                    // Track extents
                    minX = Math.min(minX, pts[i].e);
                    maxX = Math.max(maxX, pts[i].e);
                    minY = Math.min(minY, pts[i].n);
                    maxY = Math.max(maxY, pts[i].n);
                }

                // Add padding (20% on each side)
                const width = maxX - minX;
                const height = maxY - minY;
                const padding = Math.max(width, height) * 0.2;
                minX -= padding;
                maxX += padding;
                minY -= padding;
                maxY += padding;

                // Make square (use the larger dimension)
                const size = Math.max(maxX - minX, maxY - minY);
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                fieldExtents = {
                    minX: centerX - size / 2,
                    maxX: centerX + size / 2,
                    minY: centerY - size / 2,
                    maxY: centerY + size / 2,
                    size: size,
                    centerX: centerX,
                    centerY: centerY
                };

                console.log('Field extents:', fieldExtents);
                console.log('Boundary line segments:', boundary.length / 4);
            } else {
                fieldExtents = null;
            }

            // Invalidate grid cache so it re-renders with boundary
            gridTextureValid = false;
        }

        function clearBoundary() {
            fieldBoundary = null;
            boundary = [];
            fieldExtents = null;
            gridTextureValid = false;
        }

        // ===== Start =====
        requestAnimationFrame(render);

        console.log('AgOpenGPS WebGL POC loaded - with WebSocket and Panel Management');
    </script>
</body>
</html>
