<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AgOpenGPS - WebGL POC</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
        }

        #app {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 64px 1fr;
            grid-template-rows: 1fr;
        }

        /* Left Navigation Bar */
        #nav-bar {
            background: rgba(30, 42, 56, 0.95);
            padding: 8px 4px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }

        .nav-btn {
            width: 56px;
            height: 56px;
            border: none;
            border-radius: 8px;
            background: rgba(44, 62, 80, 0.87);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
            padding: 8px;
        }

        .nav-btn img {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .nav-btn:active, .nav-btn.active {
            background: #1ABC9C;
        }

        .nav-btn:hover {
            background: rgba(52, 73, 94, 0.95);
        }

        /* Floating Panels */
        .floating-panel {
            position: absolute;
            left: 72px;
            top: 60px;
            background: rgba(30, 42, 56, 0.95);
            border-radius: 12px;
            padding: 0;
            min-width: 280px;
            max-width: 320px;
            z-index: 200;
            display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        .floating-panel.visible {
            display: block;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            cursor: move;
        }

        .panel-title {
            color: #1ABC9C;
            font-weight: bold;
            font-size: 16px;
        }

        .panel-close {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-close:hover {
            background: #E74C3C;
        }

        .panel-content {
            padding: 12px;
        }

        .panel-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .panel-btn {
            height: 48px;
            border: none;
            border-radius: 8px;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            text-align: left;
        }

        .panel-btn img {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .panel-btn:hover {
            background: rgba(52, 73, 94, 0.95);
        }

        .panel-btn:active {
            background: #1ABC9C;
        }

        .panel-btn.full-width {
            grid-column: span 2;
        }

        /* Map Container */
        #map-container {
            position: relative;
            overflow: hidden;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Status Panels */
        .status-panel {
            background: rgba(26, 26, 26, 0.8);
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-weight: bold;
        }

        #top-status {
            position: absolute;
            top: 16px;
            left: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
            pointer-events: none;
        }

        #top-status > * {
            pointer-events: auto;
        }

        #gps-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #gps-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2ecc71;
        }

        #speed-display {
            font-size: 20px;
        }

        #speed-display span {
            font-size: 12px;
            color: #888;
        }

        #xte-display {
            flex: 1;
            text-align: center;
        }

        #xte-display .label {
            color: #1ABC9C;
            font-size: 14px;
        }

        #xte-display .value {
            color: yellow;
            font-size: 32px;
        }

        #xte-display .unit {
            color: #888;
            font-size: 14px;
        }

        #heading-display {
            font-size: 20px;
        }

        #heading-display span {
            color: #888;
        }

        /* Right Controls */
        #right-controls {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            background: rgba(44, 62, 80, 0.87);
            color: white;
            font-size: 24px;
            cursor: pointer;
        }

        .control-btn:active {
            background: #1ABC9C;
        }

        /* Bottom Status */
        #bottom-status {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }

        .coord-label {
            font-size: 14px;
            font-weight: bold;
        }

        .coord-value {
            font-size: 16px;
        }

        #easting .coord-label { color: #3498DB; }
        #northing .coord-label { color: #E74C3C; }

        /* Simulator Panel Controls */
        .sim-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .sim-row {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        .sim-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .sim-section label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            text-align: center;
        }

        .sim-value {
            min-width: 50px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #1ABC9C;
        }

        .sim-btn {
            height: 36px;
            padding: 0 16px;
            border: none;
            border-radius: 6px;
            background: #34495E;
            color: white;
            font-size: 14px;
            cursor: pointer;
            min-width: 60px;
        }

        .sim-btn:hover {
            background: rgba(52, 73, 94, 0.95);
        }

        .sim-btn:active {
            background: #1ABC9C;
        }

        .sim-btn.active {
            background: #1ABC9C;
        }

        .sim-btn.danger {
            background: #8B0000;
        }

        .sim-btn.danger:hover {
            background: #A00000;
        }

        .sim-arrow {
            width: 36px;
            height: 36px;
            padding: 0;
            min-width: 36px;
            font-size: 16px;
        }

        .sim-steer-indicator {
            height: 8px;
            background: #2C3E50;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .sim-steer-bar {
            position: absolute;
            top: 0;
            height: 100%;
            width: 10px;
            background: #1ABC9C;
            border-radius: 4px;
            left: 50%;
            transform: translateX(-50%);
            transition: left 0.1s ease-out;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Left Navigation -->
        <nav id="nav-bar">
            <button class="nav-btn" id="btn-file" title="File Menu"><img src="icons/fileMenu.png" alt="File"></button>
            <button class="nav-btn" id="btn-view" title="View Settings"><img src="icons/NavigationSettings.png" alt="View"></button>
            <button class="nav-btn" id="btn-tools" title="Tools"><img src="icons/SpecialFunctions.png" alt="Tools"></button>
            <button class="nav-btn" id="btn-config" title="Configuration"><img src="icons/Settings48.png" alt="Config"></button>
            <button class="nav-btn" id="btn-job" title="Job Menu"><img src="icons/JobActive.png" alt="Job"></button>
            <button class="nav-btn" id="btn-field" title="Field Tools"><img src="icons/FieldTools.png" alt="Field"></button>
            <button class="nav-btn" id="btn-steer" title="AutoSteer"><img src="icons/AutoSteerConf.png" alt="Steer"></button>
            <button class="nav-btn" id="btn-agio" title="Data I/O"><img src="icons/AgIO.png" alt="AgIO"></button>
        </nav>

        <!-- Map Area -->
        <div id="map-container">
            <canvas id="map-canvas"></canvas>

            <!-- Top Status Bar -->
            <div id="top-status">
                <div id="gps-status" class="status-panel">
                    <div id="gps-dot"></div>
                    <span id="fix-quality">RTK</span>
                </div>
                <div id="speed-display" class="status-panel">
                    <span id="speed-value">0.0</span> <span>km/h</span>
                </div>
                <div id="xte-display" class="status-panel">
                    <span class="label">XTE</span>
                    <span class="value" id="xte-value">0.00</span>
                    <span class="unit">m</span>
                </div>
                <div id="heading-display" class="status-panel">
                    <span id="heading-value">0</span><span>°</span>
                </div>
            </div>

            <!-- Right Controls -->
            <div id="right-controls">
                <button class="control-btn" id="zoom-in">+</button>
                <button class="control-btn" id="toggle-3d">3D</button>
                <button class="control-btn" id="zoom-out">−</button>
            </div>

            <!-- Bottom Position -->
            <div id="bottom-status" class="status-panel">
                <div id="easting">
                    <span class="coord-label">E</span>
                    <span class="coord-value" id="easting-value">0.0</span>
                </div>
                <div id="northing">
                    <span class="coord-label">N</span>
                    <span class="coord-value" id="northing-value">0.0</span>
                </div>
            </div>

            <!-- Simulator Control Panel (floating) -->
            <div id="panel-simulator" class="floating-panel" style="top: auto; bottom: 80px; left: 72px; min-width: 200px;">
                <div class="panel-header">
                    <span class="panel-title">Simulator</span>
                    <button class="panel-close" data-panel="simulator">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="sim-controls">
                        <div class="sim-row">
                            <button class="sim-btn" id="sim-toggle">Start</button>
                            <button class="sim-btn danger" id="stop">Reset</button>
                        </div>
                        <div class="sim-section">
                            <label>Speed</label>
                            <div class="sim-row">
                                <button class="sim-btn sim-arrow" id="decel">-</button>
                                <span class="sim-value" id="sim-speed-display">0</span>
                                <button class="sim-btn sim-arrow" id="accel">+</button>
                            </div>
                        </div>
                        <div class="sim-section">
                            <label>Steering</label>
                            <div class="sim-row">
                                <button class="sim-btn sim-arrow" id="steer-left">&#9664;</button>
                                <button class="sim-btn" id="steer-zero">0</button>
                                <button class="sim-btn sim-arrow" id="steer-right">&#9654;</button>
                            </div>
                            <div class="sim-steer-indicator">
                                <div class="sim-steer-bar" id="steer-bar"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Floating Panels -->
            <!-- File Menu Panel -->
            <div id="panel-file" class="floating-panel">
                <div class="panel-header">
                    <span class="panel-title">File Menu</span>
                    <button class="panel-close" data-panel="file">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn"><img src="icons/FileNew.png">New Profile</button>
                        <button class="panel-btn"><img src="icons/FileOpen.png">Load Profile</button>
                        <button class="panel-btn"><img src="icons/Settings48.png">Language</button>
                        <button class="panel-btn" id="panel-sim-btn"><img src="icons/vehiclePageTractor.png">Simulator</button>
                        <button class="panel-btn"><img src="icons/GPSQuality.png">Sim Coords</button>
                        <button class="panel-btn"><img src="icons/ScreenShot.png">Kiosk Mode</button>
                        <button class="panel-btn"><img src="icons/Reset_Default.png">Reset ALL</button>
                        <button class="panel-btn"><img src="icons/AgShare.png">About</button>
                        <button class="panel-btn full-width"><img src="icons/OK64.png">Help</button>
                    </div>
                </div>
            </div>

            <!-- View Settings Panel -->
            <div id="panel-view" class="floating-panel" style="top: 120px;">
                <div class="panel-header">
                    <span class="panel-title">View Settings</span>
                    <button class="panel-close" data-panel="view">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn">Tilt Down</button>
                        <button class="panel-btn">Tilt Up</button>
                        <button class="panel-btn" id="btn-2d3d">2D / 3D</button>
                        <button class="panel-btn" id="btn-north">North Up</button>
                        <button class="panel-btn" id="btn-grid-toggle">Grid</button>
                        <button class="panel-btn" id="btn-daynight">Day/Night</button>
                        <button class="panel-btn">Dim -</button>
                        <button class="panel-btn">Bright +</button>
                    </div>
                </div>
            </div>

            <!-- Tools Panel -->
            <div id="panel-tools" class="floating-panel" style="top: 180px;">
                <div class="panel-header">
                    <span class="panel-title">Tools</span>
                    <button class="panel-close" data-panel="tools">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn"><img src="icons/WizardWand.png">Steer Wizard</button>
                        <button class="panel-btn"><img src="icons/Boundary.png">Boundary Tool</button>
                        <button class="panel-btn"><img src="icons/AutoSteerOn.png">Steer Chart</button>
                        <button class="panel-btn"><img src="icons/ABSmooth.png">Smooth AB</button>
                        <button class="panel-btn"><img src="icons/ConS_SourcesHeading.png">Heading Chart</button>
                        <button class="panel-btn"><img src="icons/TrashContourRef.png">Del Contours</button>
                        <button class="panel-btn"><img src="icons/AutoManualIsAuto.png">XTE Chart</button>
                        <button class="panel-btn"><img src="icons/YouTurnReverse.png">Offset Fix</button>
                        <button class="panel-btn"><img src="icons/ConS_SourcesRoll.png">Roll Correction</button>
                        <button class="panel-btn"><img src="icons/ABTracks.png">Log Viewer</button>
                    </div>
                </div>
            </div>

            <!-- Configuration Panel -->
            <div id="panel-config" class="floating-panel" style="top: 240px;">
                <div class="panel-header">
                    <span class="panel-title">Configuration</span>
                    <button class="panel-close" data-panel="config">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn"><img src="icons/Settings48.png">Configuration</button>
                        <button class="panel-btn"><img src="icons/GPSQuality.png">GPS Data</button>
                        <button class="panel-btn"><img src="icons/AutoSteerOff.png">Auto Steer</button>
                        <button class="panel-btn"><img src="icons/ColourPick.png">Colors</button>
                        <button class="panel-btn"><img src="icons/ScreenShot.png">All Settings</button>
                        <button class="panel-btn"><img src="icons/SectionMapping.png">Section Colors</button>
                        <button class="panel-btn"><img src="icons/FileOpen.png">Directories</button>
                        <button class="panel-btn"><img src="icons/ConD_KeyBoard.png">HotKeys</button>
                    </div>
                </div>
            </div>

            <!-- Job Menu Panel -->
            <div id="panel-job" class="floating-panel" style="top: 300px;">
                <div class="panel-header">
                    <span class="panel-title">Job Menu</span>
                    <button class="panel-close" data-panel="job">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn"><img src="icons/ISOXML.png">ISO-XML</button>
                        <button class="panel-btn"><img src="icons/FileClose.png">Close Field</button>
                        <button class="panel-btn"><img src="icons/GoogleEarth.png">From KML</button>
                        <button class="panel-btn"><img src="icons/SteerDriveOn.png">Drive In</button>
                        <button class="panel-btn"><img src="icons/FileExisting.png">From Existing</button>
                        <button class="panel-btn"><img src="icons/FileOpen.png">Open Field</button>
                        <button class="panel-btn"><img src="icons/FileNew.png">New Default</button>
                        <button class="panel-btn"><img src="icons/FilePrevious.png">Resume</button>
                    </div>
                </div>
            </div>

            <!-- Field Tools Panel -->
            <div id="panel-field" class="floating-panel" style="top: 360px;">
                <div class="panel-header">
                    <span class="panel-title">Field Tools</span>
                    <button class="panel-close" data-panel="field">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn" id="btn-boundary"><img src="icons/Boundary.png">Boundary</button>
                        <button class="panel-btn"><img src="icons/HeadlandBuild.png">Headland</button>
                        <button class="panel-btn"><img src="icons/TramAll.png">Tram Lines</button>
                        <button class="panel-btn"><img src="icons/Headache.png">Headland Build</button>
                        <button class="panel-btn"><img src="icons/TrashApplied.png">Delete Applied</button>
                        <button class="panel-btn"><img src="icons/TramMulti.png">Tram Build</button>
                        <button class="panel-btn"><img src="icons/RecPath.png">Recorded Path</button>
                        <button class="panel-btn"><img src="icons/BoundaryFromTracks.png">Import Tracks</button>
                    </div>
                </div>
            </div>

            <!-- AutoSteer Panel -->
            <div id="panel-steer" class="floating-panel" style="top: 420px;">
                <div class="panel-header">
                    <span class="panel-title">AutoSteer</span>
                    <button class="panel-close" data-panel="steer">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn full-width"><img src="icons/AutoSteerConf.png">AutoSteer Config</button>
                        <button class="panel-btn"><img src="icons/AutoSteerOn.png">Steer Enable</button>
                        <button class="panel-btn"><img src="icons/AutoSteerOff.png">Steer Disable</button>
                    </div>
                </div>
            </div>

            <!-- AgIO Panel -->
            <div id="panel-agio" class="floating-panel" style="top: 480px;">
                <div class="panel-header">
                    <span class="panel-title">Data I/O</span>
                    <button class="panel-close" data-panel="agio">&times;</button>
                </div>
                <div class="panel-content">
                    <div class="panel-grid">
                        <button class="panel-btn full-width"><img src="icons/AgIO.png">AgIO Connection</button>
                        <button class="panel-btn"><img src="icons/FileOpen.png">Import</button>
                        <button class="panel-btn"><img src="icons/AgShare.png">Export</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== WebGL Map Renderer =====
        const canvas = document.getElementById('map-canvas');
        const gl = canvas.getContext('webgl', {
            antialias: true,
            alpha: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false
        });

        // Enable line smoothing if available
        if (gl) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            // Try to set line width (limited support, but helps where available)
            gl.lineWidth(1.5);
        }

        if (!gl) {
            alert('WebGL not supported - falling back to Canvas2D');
        }

        // State
        let camera = { x: 0, y: 0, zoom: 1, rotation: 0 };
        let vehicle = { x: 0, y: 0, heading: 0 };
        let simulator = { enabled: false, speed: 0, steerAngle: 0, targetSpeedKmh: 0 };
        let boundary = [];
        let lastTime = 0;

        // Touch state
        let touches = {};
        let lastPinchDist = 0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // Resize handler
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resize);
        resize();

        // ===== Shaders =====
        const vertexShaderSrc = `
            precision highp float;
            attribute vec2 a_position;
            uniform mat3 u_matrix;
            void main() {
                vec3 pos = u_matrix * vec3(a_position, 1.0);
                gl_Position = vec4(pos.xy, 0.0, 1.0);
                gl_PointSize = 4.0;
            }
        `;

        const fragmentShaderSrc = `
            precision highp float;
            uniform vec4 u_color;
            void main() {
                gl_FragColor = u_color;
            }
        `;

        // Shader for thick anti-aliased lines (drawn as quads)
        const thickLineVertexSrc = `
            precision highp float;
            attribute vec2 a_position;
            attribute float a_edge; // 0.0 = center, 1.0 = edge (for AA)
            uniform mat3 u_matrix;
            varying float v_edge;
            void main() {
                vec3 pos = u_matrix * vec3(a_position, 1.0);
                gl_Position = vec4(pos.xy, 0.0, 1.0);
                v_edge = a_edge;
            }
        `;

        const thickLineFragmentSrc = `
            precision highp float;
            uniform vec4 u_color;
            varying float v_edge;
            void main() {
                // Smooth anti-aliasing at edges
                float alpha = u_color.a * (1.0 - smoothstep(0.5, 1.0, v_edge));
                gl_FragColor = vec4(u_color.rgb, alpha);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vs = createShader(gl.VERTEX_SHADER, vertexShaderSrc);
        const fs = createShader(gl.FRAGMENT_SHADER, fragmentShaderSrc);
        const program = createProgram(vs, fs);

        const a_position = gl.getAttribLocation(program, 'a_position');
        const u_matrix = gl.getUniformLocation(program, 'u_matrix');
        const u_color = gl.getUniformLocation(program, 'u_color');

        const positionBuffer = gl.createBuffer();

        // Thick line program
        const tlVs = createShader(gl.VERTEX_SHADER, thickLineVertexSrc);
        const tlFs = createShader(gl.FRAGMENT_SHADER, thickLineFragmentSrc);
        const thickLineProgram = createProgram(tlVs, tlFs);

        const tl_a_position = gl.getAttribLocation(thickLineProgram, 'a_position');
        const tl_a_edge = gl.getAttribLocation(thickLineProgram, 'a_edge');
        const tl_u_matrix = gl.getUniformLocation(thickLineProgram, 'u_matrix');
        const tl_u_color = gl.getUniformLocation(thickLineProgram, 'u_color');

        const thickLineBuffer = gl.createBuffer();
        const edgeBuffer = gl.createBuffer();

        // ===== Grid Texture Cache =====
        // Render grid to texture once, then scroll with linear filtering
        const GRID_TEX_SIZE = 1024; // Texture size in pixels
        const GRID_WORLD_SIZE = 400; // World units covered by texture (must be multiple of grid spacing)

        // Create framebuffer for grid texture
        const gridTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, gridTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, GRID_TEX_SIZE, GRID_TEX_SIZE, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        // LINEAR filtering is key for smooth scrolling!
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

        const gridFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, gridFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, gridTexture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // Texture shader for drawing the cached grid
        const texVertexSrc = `
            precision highp float;
            attribute vec2 a_position;
            attribute vec2 a_texcoord;
            varying vec2 v_texcoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texcoord = a_texcoord;
            }
        `;
        const texFragmentSrc = `
            precision highp float;
            uniform sampler2D u_texture;
            varying vec2 v_texcoord;
            void main() {
                gl_FragColor = texture2D(u_texture, v_texcoord);
            }
        `;

        const texVs = createShader(gl.VERTEX_SHADER, texVertexSrc);
        const texFs = createShader(gl.FRAGMENT_SHADER, texFragmentSrc);
        const texProgram = createProgram(texVs, texFs);
        const tex_a_position = gl.getAttribLocation(texProgram, 'a_position');
        const tex_a_texcoord = gl.getAttribLocation(texProgram, 'a_texcoord');
        const tex_u_texture = gl.getUniformLocation(texProgram, 'u_texture');

        const quadBuffer = gl.createBuffer();
        const texcoordBuffer = gl.createBuffer();

        // Fullscreen quad vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        let gridTextureValid = false;

        function renderGridToTexture() {
            // Render grid pattern to texture (only needs to be done once or when zoom changes)
            gl.bindFramebuffer(gl.FRAMEBUFFER, gridFramebuffer);
            gl.viewport(0, 0, GRID_TEX_SIZE, GRID_TEX_SIZE);
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            // Set up matrix for texture rendering (centered at 0,0, covering GRID_WORLD_SIZE)
            const texScale = 2 / GRID_WORLD_SIZE;
            gl.uniformMatrix3fv(u_matrix, false, new Float32Array([
                texScale, 0, 0,
                0, texScale, 0,
                0, 0, 1
            ]));

            const spacing = 20;
            const majorSpacing = 100;
            const halfSize = GRID_WORLD_SIZE / 2;

            // Minor grid lines
            let minorLines = [];
            for (let x = -halfSize; x <= halfSize; x += spacing) {
                if (x % majorSpacing !== 0) {
                    minorLines.push(x, -halfSize, x, halfSize);
                }
            }
            for (let y = -halfSize; y <= halfSize; y += spacing) {
                if (y % majorSpacing !== 0) {
                    minorLines.push(-halfSize, y, halfSize, y);
                }
            }
            if (minorLines.length > 0) {
                drawLines(minorLines, [0.28, 0.28, 0.28, 1.0]);
            }

            // Major grid lines
            let majorLines = [];
            for (let x = -halfSize; x <= halfSize; x += majorSpacing) {
                majorLines.push(x, -halfSize, x, halfSize);
            }
            for (let y = -halfSize; y <= halfSize; y += majorSpacing) {
                majorLines.push(-halfSize, y, halfSize, y);
            }
            if (majorLines.length > 0) {
                drawLines(majorLines, [0.45, 0.45, 0.45, 1.0]);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gridTextureValid = true;
        }

        function drawCachedGrid() {
            if (!gridTextureValid) {
                renderGridToTexture();
            }

            // Calculate texture coordinates based on camera position
            // The texture tiles every GRID_WORLD_SIZE units
            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;

            // Texture coordinate offset (normalized 0-1, will wrap due to REPEAT)
            const texOffsetX = camera.x / GRID_WORLD_SIZE;
            const texOffsetY = camera.y / GRID_WORLD_SIZE;

            // How much of the texture to show (based on zoom)
            const texScaleX = viewWidth / GRID_WORLD_SIZE;
            const texScaleY = viewHeight / GRID_WORLD_SIZE;

            // Calculate texcoords for the quad corners
            const left = texOffsetX - texScaleX / 2;
            const right = texOffsetX + texScaleX / 2;
            const bottom = texOffsetY - texScaleY / 2;
            const top = texOffsetY + texScaleY / 2;

            gl.useProgram(texProgram);

            // Quad vertices (fullscreen)
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(tex_a_position);
            gl.vertexAttribPointer(tex_a_position, 2, gl.FLOAT, false, 0, 0);

            // Texcoords
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                left, bottom, right, bottom, left, top,
                left, top, right, bottom, right, top
            ]), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tex_a_texcoord);
            gl.vertexAttribPointer(tex_a_texcoord, 2, gl.FLOAT, false, 0, 0);

            // Bind texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, gridTexture);
            gl.uniform1i(tex_u_texture, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Switch back to main program
            gl.useProgram(program);
        }

        // ===== Transform Matrix =====
        function getMatrix() {
            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;

            // Scale to clip space
            const sx = 2 / viewWidth;
            const sy = 2 / viewHeight;

            // Direct camera position (no smoothing needed - grid uses texture now)
            const tx = -camera.x;
            const ty = -camera.y;

            // Rotation
            const cos = Math.cos(-camera.rotation);
            const sin = Math.sin(-camera.rotation);

            // Combined matrix: scale * rotate * translate
            return new Float32Array([
                sx * cos, sx * sin, 0,
                -sy * sin, sy * cos, 0,
                (tx * cos - ty * sin) * sx, (tx * sin + ty * cos) * sy, 1
            ]);
        }

        // For vehicle smoothing only
        let smoothCamX = 0;
        let smoothCamY = 0;

        // ===== Drawing Functions =====
        function drawLines(vertices, color, mode = gl.LINES) {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(u_color, color);
            gl.drawArrays(mode, 0, vertices.length / 2);
        }

        // Draw thick anti-aliased lines as quads
        // lineWidth is in world units (meters)
        function drawThickLines(lineSegments, color, lineWidth = 0.5) {
            if (lineSegments.length < 4) return;

            // Each line segment (x1,y1,x2,y2) becomes 2 triangles (6 vertices)
            const positions = [];
            const edges = [];

            for (let i = 0; i < lineSegments.length; i += 4) {
                const x1 = lineSegments[i];
                const y1 = lineSegments[i + 1];
                const x2 = lineSegments[i + 2];
                const y2 = lineSegments[i + 3];

                // Calculate perpendicular direction
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) continue;

                // Perpendicular unit vector
                const px = -dy / len;
                const py = dx / len;

                // Half width offset
                const hw = lineWidth / 2;

                // 4 corners of the quad
                const ax = x1 + px * hw, ay = y1 + py * hw;
                const bx = x1 - px * hw, by = y1 - py * hw;
                const cx = x2 + px * hw, cy = y2 + py * hw;
                const dx2 = x2 - px * hw, dy2 = y2 - py * hw;

                // Two triangles (6 vertices)
                // Triangle 1: a, b, c
                positions.push(ax, ay, bx, by, cx, cy);
                edges.push(1, 1, 0); // edges at corners, center in middle

                // Triangle 2: b, d, c
                positions.push(bx, by, dx2, dy2, cx, cy);
                edges.push(1, 1, 0);
            }

            if (positions.length === 0) return;

            gl.useProgram(thickLineProgram);
            gl.uniformMatrix3fv(tl_u_matrix, false, getMatrix());
            gl.uniform4fv(tl_u_color, color);

            // Position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, thickLineBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tl_a_position);
            gl.vertexAttribPointer(tl_a_position, 2, gl.FLOAT, false, 0, 0);

            // Edge buffer (for AA)
            gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(edges), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tl_a_edge);
            gl.vertexAttribPointer(tl_a_edge, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);

            // Switch back to simple program
            gl.useProgram(program);
            gl.disableVertexAttribArray(tl_a_edge);
        }

        function drawGrid() {
            // AOG-style grid: 20m minor, 100m major
            const spacing = 20;
            const majorSpacing = 100;
            const viewRange = 250;

            // Use integer grid positions to avoid floating point issues
            const camXGrid = Math.round(camera.x / spacing) * spacing;
            const camYGrid = Math.round(camera.y / spacing) * spacing;

            // Calculate visible grid range centered on snapped camera
            const minX = camXGrid - viewRange;
            const maxX = camXGrid + viewRange;
            const minY = camYGrid - viewRange;
            const maxY = camYGrid + viewRange;

            // Minor grid lines (use exact integer positions)
            let minorLines = [];
            for (let x = minX; x <= maxX; x += spacing) {
                if (x % majorSpacing !== 0) {
                    minorLines.push(x, minY, x, maxY);
                }
            }
            for (let y = minY; y <= maxY; y += spacing) {
                if (y % majorSpacing !== 0) {
                    minorLines.push(minX, y, maxX, y);
                }
            }
            if (minorLines.length > 0) {
                drawLines(minorLines, [0.28, 0.28, 0.28, 1.0]);
            }

            // Major grid lines
            const majorMinX = Math.floor(minX / majorSpacing) * majorSpacing;
            const majorMaxX = Math.ceil(maxX / majorSpacing) * majorSpacing;
            const majorMinY = Math.floor(minY / majorSpacing) * majorSpacing;
            const majorMaxY = Math.ceil(maxY / majorSpacing) * majorSpacing;

            let majorLines = [];
            for (let x = majorMinX; x <= majorMaxX; x += majorSpacing) {
                majorLines.push(x, majorMinY, x, majorMaxY);
            }
            for (let y = majorMinY; y <= majorMaxY; y += majorSpacing) {
                majorLines.push(majorMinX, y, majorMaxX, y);
            }
            if (majorLines.length > 0) {
                drawLines(majorLines, [0.45, 0.45, 0.45, 1.0]);
            }

            // Axes (at world origin)
            if (minY <= 0 && maxY >= 0) {
                drawLines([minX, 0, maxX, 0], [0.8, 0.2, 0.2, 1]);
            }
            if (minX <= 0 && maxX >= 0) {
                drawLines([0, minY, 0, maxY], [0.2, 0.8, 0.2, 1]);
            }
        }

        // Smoothed values for stable rendering
        let smoothedHeading = 0;
        let lastHeading = 0;
        let headingVelocity = 0; // radians per second
        let lastHeadingTime = 0;

        function drawVehicleScreenSpace() {
            const now = performance.now();
            const dt = lastHeadingTime > 0 ? (now - lastHeadingTime) / 1000 : 0.016;
            lastHeadingTime = now;

            // Detect heading changes and calculate angular velocity
            let headingDelta = vehicle.heading - lastHeading;
            if (headingDelta > Math.PI) headingDelta -= 2 * Math.PI;
            if (headingDelta < -Math.PI) headingDelta += 2 * Math.PI;

            if (Math.abs(headingDelta) > 0.001) {
                // New heading received - update velocity estimate
                headingVelocity = headingDelta / 0.1; // Assume 10Hz updates
                lastHeading = vehicle.heading;
            }

            // Predict heading based on velocity (interpolate between updates)
            let targetHeading = smoothedHeading + headingVelocity * dt;

            // Also blend toward actual heading to prevent drift
            let errorToActual = vehicle.heading - targetHeading;
            if (errorToActual > Math.PI) errorToActual -= 2 * Math.PI;
            if (errorToActual < -Math.PI) errorToActual += 2 * Math.PI;
            targetHeading += errorToActual * 0.1;

            // Smooth toward target
            let delta = targetHeading - smoothedHeading;
            if (delta > Math.PI) delta -= 2 * Math.PI;
            if (delta < -Math.PI) delta += 2 * Math.PI;
            smoothedHeading += delta * 0.3;

            const size = 6;
            const cos = Math.cos(smoothedHeading);
            const sin = Math.sin(smoothedHeading);

            // Get aspect and view dimensions to convert to clip space
            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;
            const sx = 2 / viewWidth;
            const sy = 2 / viewHeight;

            // Triangle vertices - use simple geometry
            const frontDist = size;
            const backDist = size * 0.5;
            const sideDist = size * 0.4;

            // Calculate in world coords then scale to clip
            const tipX = sin * frontDist * sx;
            const tipY = cos * frontDist * sy;
            const leftX = (-cos * sideDist - sin * backDist) * sx;
            const leftY = (sin * sideDist - cos * backDist) * sy;
            const rightX = (cos * sideDist - sin * backDist) * sx;
            const rightY = (-sin * sideDist - cos * backDist) * sy;

            // Draw directly in clip space with identity matrix
            gl.uniformMatrix3fv(u_matrix, false, new Float32Array([1,0,0, 0,1,0, 0,0,1]));

            // Draw filled triangle
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                tipX, tipY, leftX, leftY, rightX, rightY
            ]), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(u_color, [0.2, 0.85, 0.2, 1.0]);
            gl.drawArrays(gl.TRIANGLES, 0, 3);

            // Restore world matrix
            gl.uniformMatrix3fv(u_matrix, false, getMatrix());
        }

        function drawVehicle() {
            const size = 5;
            const cos = Math.cos(vehicle.heading);
            const sin = Math.sin(vehicle.heading);

            // Draw vehicle at camera position (center of view)
            const cx = camera.x;
            const cy = camera.y;

            // Triangle pointing in heading direction
            const tip = [cx + sin * size, cy + cos * size];
            const left = [cx - cos * size/3 - sin * size/2, cy + sin * size/3 - cos * size/2];
            const right = [cx + cos * size/3 - sin * size/2, cy - sin * size/3 - cos * size/2];

            drawLines([
                tip[0], tip[1], left[0], left[1],
                left[0], left[1], right[0], right[1],
                right[0], right[1], tip[0], tip[1]
            ], [0.2, 1, 0.2, 1]); // Lime green
        }

        function drawBoundary() {
            if (boundary.length < 4) return;
            drawLines(boundary, [1, 1, 0, 1]); // Yellow
        }

        // ===== Main Render Loop =====
        function render(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            // Update simulator
            if (simulator.enabled) {
                updateSimulator(dt);
            }

            // Camera follows vehicle
            camera.x = vehicle.x;
            camera.y = vehicle.y;

            // Clear
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Setup
            gl.useProgram(program);
            gl.uniformMatrix3fv(u_matrix, false, getMatrix());

            // Draw cached grid (uses texture for smooth scrolling)
            drawCachedGrid();

            // Set up matrix for world-space objects
            gl.useProgram(program);
            gl.uniformMatrix3fv(u_matrix, false, getMatrix());
            drawBoundary();
            drawVehicleScreenSpace(); // Use screen-space rendering for stable vehicle

            // Update UI
            updateUI();

            requestAnimationFrame(render);
        }

        // ===== Simulator =====
        function updateSimulator(dt) {
            // Update heading based on steer angle and speed
            const turnRate = simulator.steerAngle * 0.5 * (simulator.speed / 10);
            vehicle.heading += turnRate * dt;

            // Update position based on heading and speed
            vehicle.x += Math.sin(vehicle.heading) * simulator.speed * dt;
            vehicle.y += Math.cos(vehicle.heading) * simulator.speed * dt;
        }

        // ===== UI Updates =====
        function updateUI() {
            document.getElementById('speed-value').textContent = (simulator.speed * 3.6).toFixed(1);
            document.getElementById('heading-value').textContent = ((vehicle.heading * 180 / Math.PI) % 360).toFixed(0);
            document.getElementById('easting-value').textContent = vehicle.x.toFixed(1);
            document.getElementById('northing-value').textContent = vehicle.y.toFixed(1);
        }

        // ===== Touch/Mouse Handlers =====
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let t of e.changedTouches) {
                touches[t.identifier] = { x: t.clientX, y: t.clientY };
            }
            if (Object.keys(touches).length === 1) {
                isPanning = true;
                const t = e.touches[0];
                panStart = { x: t.clientX, y: t.clientY };
            } else if (Object.keys(touches).length === 2) {
                const [t1, t2] = e.touches;
                lastPinchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                // Pinch zoom
                const [t1, t2] = e.touches;
                const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                if (lastPinchDist > 0) {
                    camera.zoom *= dist / lastPinchDist;
                    camera.zoom = Math.max(0.1, Math.min(50, camera.zoom));
                }
                lastPinchDist = dist;
            }
            // Note: Pan disabled while simulator camera follows vehicle
        });

        canvas.addEventListener('touchend', (e) => {
            for (let t of e.changedTouches) {
                delete touches[t.identifier];
            }
            if (Object.keys(touches).length < 2) {
                lastPinchDist = 0;
            }
            isPanning = false;
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom *= factor;
            camera.zoom = Math.max(0.1, Math.min(50, camera.zoom));
        });

        // ===== Button Handlers =====
        document.getElementById('zoom-in').addEventListener('click', () => {
            camera.zoom *= 1.2;
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            camera.zoom *= 0.8;
        });

        // ===== WebSocket Connection =====
        let ws = null;
        let wsConnected = false;

        function connectWebSocket() {
            const wsUrl = `ws://${window.location.host}/ws`;
            console.log('Connecting to WebSocket:', wsUrl);

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                wsConnected = true;
                document.getElementById('gps-dot').style.background = '#1ABC9C';
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                wsConnected = false;
                document.getElementById('gps-dot').style.background = '#E74C3C';
                // Reconnect after 2 seconds
                setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);

                if (msg.type === 'gps') {
                    // Update vehicle from server GPS data
                    vehicle.x = msg.data.easting;
                    vehicle.y = msg.data.northing;
                    vehicle.heading = msg.data.heading * Math.PI / 180; // degrees to radians
                    simulator.speed = msg.data.speed / 3.6; // km/h to m/s
                }
                else if (msg.type === 'connected') {
                    console.log('Connected to server, ID:', msg.connectionId);
                    if (msg.simulator) {
                        simulator.enabled = msg.simulator.running;
                        simulator.speed = msg.simulator.speed / 3.6; // km/h to m/s
                        simulator.steerAngle = msg.simulator.steerAngle;
                        // UI update will happen after updateSimulatorUI is defined
                    }
                }
                else if (msg.type === 'simulator') {
                    console.log('Simulator message:', msg);
                }
            };
        }

        function sendWsMessage(msg) {
            if (ws && wsConnected) {
                ws.send(JSON.stringify(msg));
            }
        }

        // Simulator control handlers are set up after panel management section

        // Connect to WebSocket on load
        connectWebSocket();

        // ===== Panel Management =====
        const panels = {
            file: document.getElementById('panel-file'),
            view: document.getElementById('panel-view'),
            tools: document.getElementById('panel-tools'),
            config: document.getElementById('panel-config'),
            job: document.getElementById('panel-job'),
            field: document.getElementById('panel-field'),
            steer: document.getElementById('panel-steer'),
            agio: document.getElementById('panel-agio')
        };

        const navButtons = {
            file: document.getElementById('btn-file'),
            view: document.getElementById('btn-view'),
            tools: document.getElementById('btn-tools'),
            config: document.getElementById('btn-config'),
            job: document.getElementById('btn-job'),
            field: document.getElementById('btn-field'),
            steer: document.getElementById('btn-steer'),
            agio: document.getElementById('btn-agio')
        };

        let activePanel = null;

        function togglePanel(panelName) {
            // If clicking the same panel, close it
            if (activePanel === panelName) {
                panels[panelName].classList.remove('visible');
                navButtons[panelName].classList.remove('active');
                activePanel = null;
                return;
            }

            // Close currently open panel
            if (activePanel) {
                panels[activePanel].classList.remove('visible');
                navButtons[activePanel].classList.remove('active');
            }

            // Open new panel
            panels[panelName].classList.add('visible');
            navButtons[panelName].classList.add('active');
            activePanel = panelName;
        }

        function closePanel(panelName) {
            panels[panelName].classList.remove('visible');
            navButtons[panelName].classList.remove('active');
            if (activePanel === panelName) {
                activePanel = null;
            }
        }

        // Wire up nav buttons
        Object.keys(navButtons).forEach(name => {
            navButtons[name].addEventListener('click', () => togglePanel(name));
        });

        // Wire up close buttons
        document.querySelectorAll('.panel-close').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const panelName = e.target.dataset.panel;
                closePanel(panelName);
            });
        });

        // Close panel when clicking outside
        document.getElementById('map-container').addEventListener('click', (e) => {
            // Only close if clicking directly on map-container or canvas
            if (e.target.id === 'map-container' || e.target.id === 'map-canvas') {
                if (activePanel) {
                    closePanel(activePanel);
                }
            }
        });

        // Make panels draggable
        document.querySelectorAll('.panel-header').forEach(header => {
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            const panel = header.parentElement;

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('panel-close')) return;
                isDragging = true;
                const rect = panel.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const containerRect = document.getElementById('map-container').getBoundingClientRect();
                let newX = e.clientX - containerRect.left - dragOffset.x;
                let newY = e.clientY - containerRect.top - dragOffset.y;
                // Keep within bounds
                newX = Math.max(0, Math.min(containerRect.width - panel.offsetWidth, newX));
                newY = Math.max(0, Math.min(containerRect.height - panel.offsetHeight, newY));
                panel.style.left = newX + 'px';
                panel.style.top = newY + 'px';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch support for dragging
            header.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('panel-close')) return;
                isDragging = true;
                const touch = e.touches[0];
                const rect = panel.getBoundingClientRect();
                dragOffset.x = touch.clientX - rect.left;
                dragOffset.y = touch.clientY - rect.top;
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const containerRect = document.getElementById('map-container').getBoundingClientRect();
                let newX = touch.clientX - containerRect.left - dragOffset.x;
                let newY = touch.clientY - containerRect.top - dragOffset.y;
                newX = Math.max(0, Math.min(containerRect.width - panel.offsetWidth, newX));
                newY = Math.max(0, Math.min(containerRect.height - panel.offsetHeight, newY));
                panel.style.left = newX + 'px';
                panel.style.top = newY + 'px';
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        });

        // ===== Simulator Panel =====
        const simulatorPanel = document.getElementById('panel-simulator');
        let simulatorPanelVisible = false;

        function toggleSimulatorPanel() {
            simulatorPanelVisible = !simulatorPanelVisible;
            simulatorPanel.classList.toggle('visible', simulatorPanelVisible);
            // Update menu button state
            document.getElementById('panel-sim-btn').classList.toggle('active', simulatorPanelVisible);
        }

        function updateSimulatorUI() {
            const simToggle = document.getElementById('sim-toggle');
            simToggle.textContent = simulator.enabled ? 'Stop' : 'Start';
            simToggle.classList.toggle('active', simulator.enabled);

            // Update speed display - use targetSpeedKmh (not actual speed from GPS which can have timing drift)
            document.getElementById('sim-speed-display').textContent = simulator.targetSpeedKmh.toFixed(0) + ' km/h';

            // Update steer bar position (steerAngle is -45 to 45)
            const steerPercent = 50 + (simulator.steerAngle / 45) * 40; // 10% to 90%
            document.getElementById('steer-bar').style.left = steerPercent + '%';
        }

        // File Menu > Simulator button - opens/closes the simulator panel
        document.getElementById('panel-sim-btn').addEventListener('click', () => {
            closePanel('file');
            toggleSimulatorPanel();
        });

        // Simulator panel close button
        simulatorPanel.querySelector('.panel-close').addEventListener('click', () => {
            simulatorPanelVisible = false;
            simulatorPanel.classList.remove('visible');
            document.getElementById('panel-sim-btn').classList.remove('active');
        });

        // Start/Stop button in simulator panel
        document.getElementById('sim-toggle').addEventListener('click', () => {
            simulator.enabled = !simulator.enabled;
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: simulator.enabled ? 'start' : 'stop' });
        });

        // Speed controls - track speed in km/h on simulator object to avoid server sync issues
        document.getElementById('accel').addEventListener('click', () => {
            simulator.targetSpeedKmh = Math.min(25, simulator.targetSpeedKmh + 5);
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: simulator.targetSpeedKmh });
        });

        document.getElementById('decel').addEventListener('click', () => {
            simulator.targetSpeedKmh = Math.max(0, simulator.targetSpeedKmh - 5);
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: simulator.targetSpeedKmh });
        });

        // Reset button
        document.getElementById('stop').addEventListener('click', () => {
            simulator.targetSpeedKmh = 0;
            simulator.speed = 0;
            simulator.steerAngle = 0;
            simulator.enabled = false;
            vehicle.x = 0;
            vehicle.y = 0;
            vehicle.heading = 0;
            smoothedHeading = 0;
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'stop' });
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: 0 });
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: 0 });
            sendWsMessage({ type: 'simulator', action: 'setPosition', latitude: 40.7128, longitude: -74.0060 });
        });

        // Steering controls
        document.getElementById('steer-left').addEventListener('click', () => {
            simulator.steerAngle = Math.max(-45, simulator.steerAngle - 5);
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: simulator.steerAngle });
        });

        document.getElementById('steer-right').addEventListener('click', () => {
            simulator.steerAngle = Math.min(45, simulator.steerAngle + 5);
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: simulator.steerAngle });
        });

        document.getElementById('steer-zero').addEventListener('click', () => {
            simulator.steerAngle = 0;
            updateSimulatorUI();
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: 0 });
        });

        // Make simulator panel draggable
        (function() {
            const header = simulatorPanel.querySelector('.panel-header');
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('panel-close')) return;
                isDragging = true;
                const rect = simulatorPanel.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const containerRect = document.getElementById('map-container').getBoundingClientRect();
                let newX = e.clientX - containerRect.left - dragOffset.x;
                let newY = e.clientY - containerRect.top - dragOffset.y;
                newX = Math.max(0, Math.min(containerRect.width - simulatorPanel.offsetWidth, newX));
                newY = Math.max(0, Math.min(containerRect.height - simulatorPanel.offsetHeight, newY));
                simulatorPanel.style.left = newX + 'px';
                simulatorPanel.style.top = newY + 'px';
                simulatorPanel.style.bottom = 'auto';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch support
            header.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('panel-close')) return;
                isDragging = true;
                const touch = e.touches[0];
                const rect = simulatorPanel.getBoundingClientRect();
                dragOffset.x = touch.clientX - rect.left;
                dragOffset.y = touch.clientY - rect.top;
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const containerRect = document.getElementById('map-container').getBoundingClientRect();
                let newX = touch.clientX - containerRect.left - dragOffset.x;
                let newY = touch.clientY - containerRect.top - dragOffset.y;
                newX = Math.max(0, Math.min(containerRect.width - simulatorPanel.offsetWidth, newX));
                newY = Math.max(0, Math.min(containerRect.height - simulatorPanel.offsetHeight, newY));
                simulatorPanel.style.left = newX + 'px';
                simulatorPanel.style.top = newY + 'px';
                simulatorPanel.style.bottom = 'auto';
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        })();

        // ===== Start =====
        requestAnimationFrame(render);

        console.log('AgOpenGPS WebGL POC loaded - with WebSocket and Panel Management');
    </script>
</body>
</html>
