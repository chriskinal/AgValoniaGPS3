<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AgOpenGPS - WebGL POC</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
        }

        #app {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 64px 1fr;
            grid-template-rows: 1fr;
        }

        /* Left Navigation Bar */
        #nav-bar {
            background: rgba(30, 42, 56, 0.87);
            padding: 8px 4px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }

        .nav-btn {
            width: 56px;
            height: 56px;
            border: none;
            border-radius: 8px;
            background: rgba(44, 62, 80, 0.87);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
        }

        .nav-btn:active {
            background: #1ABC9C;
        }

        /* Map Container */
        #map-container {
            position: relative;
            overflow: hidden;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Status Panels */
        .status-panel {
            background: rgba(26, 26, 26, 0.8);
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-weight: bold;
        }

        #top-status {
            position: absolute;
            top: 16px;
            left: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
            pointer-events: none;
        }

        #top-status > * {
            pointer-events: auto;
        }

        #gps-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #gps-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2ecc71;
        }

        #speed-display {
            font-size: 20px;
        }

        #speed-display span {
            font-size: 12px;
            color: #888;
        }

        #xte-display {
            flex: 1;
            text-align: center;
        }

        #xte-display .label {
            color: #1ABC9C;
            font-size: 14px;
        }

        #xte-display .value {
            color: yellow;
            font-size: 32px;
        }

        #xte-display .unit {
            color: #888;
            font-size: 14px;
        }

        #heading-display {
            font-size: 20px;
        }

        #heading-display span {
            color: #888;
        }

        /* Right Controls */
        #right-controls {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            background: rgba(44, 62, 80, 0.87);
            color: white;
            font-size: 24px;
            cursor: pointer;
        }

        .control-btn:active {
            background: #1ABC9C;
        }

        /* Bottom Status */
        #bottom-status {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }

        .coord-label {
            font-size: 14px;
            font-weight: bold;
        }

        .coord-value {
            font-size: 16px;
        }

        #easting .coord-label { color: #3498DB; }
        #northing .coord-label { color: #E74C3C; }

        /* Simulator Panel */
        #sim-panel {
            position: absolute;
            bottom: 16px;
            left: 16px;
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .sim-btn {
            height: 32px;
            padding: 0 12px;
            border: none;
            border-radius: 6px;
            background: #34495E;
            color: white;
            font-size: 12px;
            cursor: pointer;
        }

        .sim-btn:active {
            background: #1ABC9C;
        }

        .sim-btn.active {
            background: #1ABC9C;
        }

        .sim-btn.danger {
            background: #8B0000;
        }

        .sim-arrow {
            width: 32px;
            height: 32px;
            padding: 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Left Navigation -->
        <nav id="nav-bar">
            <button class="nav-btn" title="File Menu">&#128194;</button>
            <button class="nav-btn" title="View Settings">&#128065;</button>
            <button class="nav-btn" title="Tools">&#128295;</button>
            <button class="nav-btn" title="Configuration">&#9881;</button>
            <button class="nav-btn" title="Job Menu">&#128196;</button>
            <button class="nav-btn" title="Field Tools">&#127793;</button>
            <button class="nav-btn" title="AutoSteer">&#128663;</button>
            <button class="nav-btn" title="Data I/O">&#128225;</button>
        </nav>

        <!-- Map Area -->
        <div id="map-container">
            <canvas id="map-canvas"></canvas>

            <!-- Top Status Bar -->
            <div id="top-status">
                <div id="gps-status" class="status-panel">
                    <div id="gps-dot"></div>
                    <span id="fix-quality">RTK</span>
                </div>
                <div id="speed-display" class="status-panel">
                    <span id="speed-value">0.0</span> <span>km/h</span>
                </div>
                <div id="xte-display" class="status-panel">
                    <span class="label">XTE</span>
                    <span class="value" id="xte-value">0.00</span>
                    <span class="unit">m</span>
                </div>
                <div id="heading-display" class="status-panel">
                    <span id="heading-value">0</span><span>°</span>
                </div>
            </div>

            <!-- Right Controls -->
            <div id="right-controls">
                <button class="control-btn" id="zoom-in">+</button>
                <button class="control-btn" id="toggle-3d">3D</button>
                <button class="control-btn" id="zoom-out">−</button>
            </div>

            <!-- Bottom Position -->
            <div id="bottom-status" class="status-panel">
                <div id="easting">
                    <span class="coord-label">E</span>
                    <span class="coord-value" id="easting-value">0.0</span>
                </div>
                <div id="northing">
                    <span class="coord-label">N</span>
                    <span class="coord-value" id="northing-value">0.0</span>
                </div>
            </div>

            <!-- Simulator Panel -->
            <div id="sim-panel">
                <button class="sim-btn" id="sim-toggle">Sim</button>
                <button class="sim-btn sim-arrow" id="steer-left">&#9664;</button>
                <button class="sim-btn" id="steer-zero">Zero</button>
                <button class="sim-btn sim-arrow" id="steer-right">&#9654;</button>
                <button class="sim-btn sim-arrow" id="accel">&#9650;</button>
                <button class="sim-btn" id="stop">&#9632;</button>
                <button class="sim-btn sim-arrow" id="decel">&#9660;</button>
            </div>
        </div>
    </div>

    <script>
        // ===== WebGL Map Renderer =====
        const canvas = document.getElementById('map-canvas');
        const gl = canvas.getContext('webgl', {
            antialias: true,
            alpha: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false
        });

        // Enable line smoothing if available
        if (gl) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            // Try to set line width (limited support, but helps where available)
            gl.lineWidth(1.5);
        }

        if (!gl) {
            alert('WebGL not supported - falling back to Canvas2D');
        }

        // State
        let camera = { x: 0, y: 0, zoom: 1, rotation: 0 };
        let vehicle = { x: 0, y: 0, heading: 0 };
        let simulator = { enabled: false, speed: 0, steerAngle: 0 };
        let boundary = [];
        let lastTime = 0;

        // Touch state
        let touches = {};
        let lastPinchDist = 0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // Resize handler
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resize);
        resize();

        // ===== Shaders =====
        const vertexShaderSrc = `
            precision highp float;
            attribute vec2 a_position;
            uniform mat3 u_matrix;
            void main() {
                vec3 pos = u_matrix * vec3(a_position, 1.0);
                gl_Position = vec4(pos.xy, 0.0, 1.0);
                gl_PointSize = 4.0;
            }
        `;

        const fragmentShaderSrc = `
            precision highp float;
            uniform vec4 u_color;
            void main() {
                gl_FragColor = u_color;
            }
        `;

        // Shader for thick anti-aliased lines (drawn as quads)
        const thickLineVertexSrc = `
            precision highp float;
            attribute vec2 a_position;
            attribute float a_edge; // 0.0 = center, 1.0 = edge (for AA)
            uniform mat3 u_matrix;
            varying float v_edge;
            void main() {
                vec3 pos = u_matrix * vec3(a_position, 1.0);
                gl_Position = vec4(pos.xy, 0.0, 1.0);
                v_edge = a_edge;
            }
        `;

        const thickLineFragmentSrc = `
            precision highp float;
            uniform vec4 u_color;
            varying float v_edge;
            void main() {
                // Smooth anti-aliasing at edges
                float alpha = u_color.a * (1.0 - smoothstep(0.5, 1.0, v_edge));
                gl_FragColor = vec4(u_color.rgb, alpha);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vs = createShader(gl.VERTEX_SHADER, vertexShaderSrc);
        const fs = createShader(gl.FRAGMENT_SHADER, fragmentShaderSrc);
        const program = createProgram(vs, fs);

        const a_position = gl.getAttribLocation(program, 'a_position');
        const u_matrix = gl.getUniformLocation(program, 'u_matrix');
        const u_color = gl.getUniformLocation(program, 'u_color');

        const positionBuffer = gl.createBuffer();

        // Thick line program
        const tlVs = createShader(gl.VERTEX_SHADER, thickLineVertexSrc);
        const tlFs = createShader(gl.FRAGMENT_SHADER, thickLineFragmentSrc);
        const thickLineProgram = createProgram(tlVs, tlFs);

        const tl_a_position = gl.getAttribLocation(thickLineProgram, 'a_position');
        const tl_a_edge = gl.getAttribLocation(thickLineProgram, 'a_edge');
        const tl_u_matrix = gl.getUniformLocation(thickLineProgram, 'u_matrix');
        const tl_u_color = gl.getUniformLocation(thickLineProgram, 'u_color');

        const thickLineBuffer = gl.createBuffer();
        const edgeBuffer = gl.createBuffer();

        // ===== Grid Texture Cache =====
        // Render grid to texture once, then scroll with linear filtering
        const GRID_TEX_SIZE = 1024; // Texture size in pixels
        const GRID_WORLD_SIZE = 400; // World units covered by texture (must be multiple of grid spacing)

        // Create framebuffer for grid texture
        const gridTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, gridTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, GRID_TEX_SIZE, GRID_TEX_SIZE, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        // LINEAR filtering is key for smooth scrolling!
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

        const gridFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, gridFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, gridTexture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // Texture shader for drawing the cached grid
        const texVertexSrc = `
            precision highp float;
            attribute vec2 a_position;
            attribute vec2 a_texcoord;
            varying vec2 v_texcoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texcoord = a_texcoord;
            }
        `;
        const texFragmentSrc = `
            precision highp float;
            uniform sampler2D u_texture;
            varying vec2 v_texcoord;
            void main() {
                gl_FragColor = texture2D(u_texture, v_texcoord);
            }
        `;

        const texVs = createShader(gl.VERTEX_SHADER, texVertexSrc);
        const texFs = createShader(gl.FRAGMENT_SHADER, texFragmentSrc);
        const texProgram = createProgram(texVs, texFs);
        const tex_a_position = gl.getAttribLocation(texProgram, 'a_position');
        const tex_a_texcoord = gl.getAttribLocation(texProgram, 'a_texcoord');
        const tex_u_texture = gl.getUniformLocation(texProgram, 'u_texture');

        const quadBuffer = gl.createBuffer();
        const texcoordBuffer = gl.createBuffer();

        // Fullscreen quad vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        let gridTextureValid = false;

        function renderGridToTexture() {
            // Render grid pattern to texture (only needs to be done once or when zoom changes)
            gl.bindFramebuffer(gl.FRAMEBUFFER, gridFramebuffer);
            gl.viewport(0, 0, GRID_TEX_SIZE, GRID_TEX_SIZE);
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            // Set up matrix for texture rendering (centered at 0,0, covering GRID_WORLD_SIZE)
            const texScale = 2 / GRID_WORLD_SIZE;
            gl.uniformMatrix3fv(u_matrix, false, new Float32Array([
                texScale, 0, 0,
                0, texScale, 0,
                0, 0, 1
            ]));

            const spacing = 20;
            const majorSpacing = 100;
            const halfSize = GRID_WORLD_SIZE / 2;

            // Minor grid lines
            let minorLines = [];
            for (let x = -halfSize; x <= halfSize; x += spacing) {
                if (x % majorSpacing !== 0) {
                    minorLines.push(x, -halfSize, x, halfSize);
                }
            }
            for (let y = -halfSize; y <= halfSize; y += spacing) {
                if (y % majorSpacing !== 0) {
                    minorLines.push(-halfSize, y, halfSize, y);
                }
            }
            if (minorLines.length > 0) {
                drawLines(minorLines, [0.28, 0.28, 0.28, 1.0]);
            }

            // Major grid lines
            let majorLines = [];
            for (let x = -halfSize; x <= halfSize; x += majorSpacing) {
                majorLines.push(x, -halfSize, x, halfSize);
            }
            for (let y = -halfSize; y <= halfSize; y += majorSpacing) {
                majorLines.push(-halfSize, y, halfSize, y);
            }
            if (majorLines.length > 0) {
                drawLines(majorLines, [0.45, 0.45, 0.45, 1.0]);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gridTextureValid = true;
        }

        function drawCachedGrid() {
            if (!gridTextureValid) {
                renderGridToTexture();
            }

            // Calculate texture coordinates based on camera position
            // The texture tiles every GRID_WORLD_SIZE units
            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;

            // Texture coordinate offset (normalized 0-1, will wrap due to REPEAT)
            const texOffsetX = camera.x / GRID_WORLD_SIZE;
            const texOffsetY = camera.y / GRID_WORLD_SIZE;

            // How much of the texture to show (based on zoom)
            const texScaleX = viewWidth / GRID_WORLD_SIZE;
            const texScaleY = viewHeight / GRID_WORLD_SIZE;

            // Calculate texcoords for the quad corners
            const left = texOffsetX - texScaleX / 2;
            const right = texOffsetX + texScaleX / 2;
            const bottom = texOffsetY - texScaleY / 2;
            const top = texOffsetY + texScaleY / 2;

            gl.useProgram(texProgram);

            // Quad vertices (fullscreen)
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(tex_a_position);
            gl.vertexAttribPointer(tex_a_position, 2, gl.FLOAT, false, 0, 0);

            // Texcoords
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                left, bottom, right, bottom, left, top,
                left, top, right, bottom, right, top
            ]), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tex_a_texcoord);
            gl.vertexAttribPointer(tex_a_texcoord, 2, gl.FLOAT, false, 0, 0);

            // Bind texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, gridTexture);
            gl.uniform1i(tex_u_texture, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Switch back to main program
            gl.useProgram(program);
        }

        // ===== Transform Matrix =====
        function getMatrix() {
            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;

            // Scale to clip space
            const sx = 2 / viewWidth;
            const sy = 2 / viewHeight;

            // Direct camera position (no smoothing needed - grid uses texture now)
            const tx = -camera.x;
            const ty = -camera.y;

            // Rotation
            const cos = Math.cos(-camera.rotation);
            const sin = Math.sin(-camera.rotation);

            // Combined matrix: scale * rotate * translate
            return new Float32Array([
                sx * cos, sx * sin, 0,
                -sy * sin, sy * cos, 0,
                (tx * cos - ty * sin) * sx, (tx * sin + ty * cos) * sy, 1
            ]);
        }

        // For vehicle smoothing only
        let smoothCamX = 0;
        let smoothCamY = 0;

        // ===== Drawing Functions =====
        function drawLines(vertices, color, mode = gl.LINES) {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(u_color, color);
            gl.drawArrays(mode, 0, vertices.length / 2);
        }

        // Draw thick anti-aliased lines as quads
        // lineWidth is in world units (meters)
        function drawThickLines(lineSegments, color, lineWidth = 0.5) {
            if (lineSegments.length < 4) return;

            // Each line segment (x1,y1,x2,y2) becomes 2 triangles (6 vertices)
            const positions = [];
            const edges = [];

            for (let i = 0; i < lineSegments.length; i += 4) {
                const x1 = lineSegments[i];
                const y1 = lineSegments[i + 1];
                const x2 = lineSegments[i + 2];
                const y2 = lineSegments[i + 3];

                // Calculate perpendicular direction
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) continue;

                // Perpendicular unit vector
                const px = -dy / len;
                const py = dx / len;

                // Half width offset
                const hw = lineWidth / 2;

                // 4 corners of the quad
                const ax = x1 + px * hw, ay = y1 + py * hw;
                const bx = x1 - px * hw, by = y1 - py * hw;
                const cx = x2 + px * hw, cy = y2 + py * hw;
                const dx2 = x2 - px * hw, dy2 = y2 - py * hw;

                // Two triangles (6 vertices)
                // Triangle 1: a, b, c
                positions.push(ax, ay, bx, by, cx, cy);
                edges.push(1, 1, 0); // edges at corners, center in middle

                // Triangle 2: b, d, c
                positions.push(bx, by, dx2, dy2, cx, cy);
                edges.push(1, 1, 0);
            }

            if (positions.length === 0) return;

            gl.useProgram(thickLineProgram);
            gl.uniformMatrix3fv(tl_u_matrix, false, getMatrix());
            gl.uniform4fv(tl_u_color, color);

            // Position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, thickLineBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tl_a_position);
            gl.vertexAttribPointer(tl_a_position, 2, gl.FLOAT, false, 0, 0);

            // Edge buffer (for AA)
            gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(edges), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(tl_a_edge);
            gl.vertexAttribPointer(tl_a_edge, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);

            // Switch back to simple program
            gl.useProgram(program);
            gl.disableVertexAttribArray(tl_a_edge);
        }

        function drawGrid() {
            // AOG-style grid: 20m minor, 100m major
            const spacing = 20;
            const majorSpacing = 100;
            const viewRange = 250;

            // Use integer grid positions to avoid floating point issues
            const camXGrid = Math.round(camera.x / spacing) * spacing;
            const camYGrid = Math.round(camera.y / spacing) * spacing;

            // Calculate visible grid range centered on snapped camera
            const minX = camXGrid - viewRange;
            const maxX = camXGrid + viewRange;
            const minY = camYGrid - viewRange;
            const maxY = camYGrid + viewRange;

            // Minor grid lines (use exact integer positions)
            let minorLines = [];
            for (let x = minX; x <= maxX; x += spacing) {
                if (x % majorSpacing !== 0) {
                    minorLines.push(x, minY, x, maxY);
                }
            }
            for (let y = minY; y <= maxY; y += spacing) {
                if (y % majorSpacing !== 0) {
                    minorLines.push(minX, y, maxX, y);
                }
            }
            if (minorLines.length > 0) {
                drawLines(minorLines, [0.28, 0.28, 0.28, 1.0]);
            }

            // Major grid lines
            const majorMinX = Math.floor(minX / majorSpacing) * majorSpacing;
            const majorMaxX = Math.ceil(maxX / majorSpacing) * majorSpacing;
            const majorMinY = Math.floor(minY / majorSpacing) * majorSpacing;
            const majorMaxY = Math.ceil(maxY / majorSpacing) * majorSpacing;

            let majorLines = [];
            for (let x = majorMinX; x <= majorMaxX; x += majorSpacing) {
                majorLines.push(x, majorMinY, x, majorMaxY);
            }
            for (let y = majorMinY; y <= majorMaxY; y += majorSpacing) {
                majorLines.push(majorMinX, y, majorMaxX, y);
            }
            if (majorLines.length > 0) {
                drawLines(majorLines, [0.45, 0.45, 0.45, 1.0]);
            }

            // Axes (at world origin)
            if (minY <= 0 && maxY >= 0) {
                drawLines([minX, 0, maxX, 0], [0.8, 0.2, 0.2, 1]);
            }
            if (minX <= 0 && maxX >= 0) {
                drawLines([0, minY, 0, maxY], [0.2, 0.8, 0.2, 1]);
            }
        }

        // Smoothed values for stable rendering
        let smoothedHeading = 0;
        let lastHeading = 0;
        let headingVelocity = 0; // radians per second
        let lastHeadingTime = 0;

        function drawVehicleScreenSpace() {
            const now = performance.now();
            const dt = lastHeadingTime > 0 ? (now - lastHeadingTime) / 1000 : 0.016;
            lastHeadingTime = now;

            // Detect heading changes and calculate angular velocity
            let headingDelta = vehicle.heading - lastHeading;
            if (headingDelta > Math.PI) headingDelta -= 2 * Math.PI;
            if (headingDelta < -Math.PI) headingDelta += 2 * Math.PI;

            if (Math.abs(headingDelta) > 0.001) {
                // New heading received - update velocity estimate
                headingVelocity = headingDelta / 0.1; // Assume 10Hz updates
                lastHeading = vehicle.heading;
            }

            // Predict heading based on velocity (interpolate between updates)
            let targetHeading = smoothedHeading + headingVelocity * dt;

            // Also blend toward actual heading to prevent drift
            let errorToActual = vehicle.heading - targetHeading;
            if (errorToActual > Math.PI) errorToActual -= 2 * Math.PI;
            if (errorToActual < -Math.PI) errorToActual += 2 * Math.PI;
            targetHeading += errorToActual * 0.1;

            // Smooth toward target
            let delta = targetHeading - smoothedHeading;
            if (delta > Math.PI) delta -= 2 * Math.PI;
            if (delta < -Math.PI) delta += 2 * Math.PI;
            smoothedHeading += delta * 0.3;

            const size = 6;
            const cos = Math.cos(smoothedHeading);
            const sin = Math.sin(smoothedHeading);

            // Get aspect and view dimensions to convert to clip space
            const aspect = canvas.width / canvas.height;
            const viewWidth = 200 / camera.zoom;
            const viewHeight = viewWidth / aspect;
            const sx = 2 / viewWidth;
            const sy = 2 / viewHeight;

            // Triangle vertices - use simple geometry
            const frontDist = size;
            const backDist = size * 0.5;
            const sideDist = size * 0.4;

            // Calculate in world coords then scale to clip
            const tipX = sin * frontDist * sx;
            const tipY = cos * frontDist * sy;
            const leftX = (-cos * sideDist - sin * backDist) * sx;
            const leftY = (sin * sideDist - cos * backDist) * sy;
            const rightX = (cos * sideDist - sin * backDist) * sx;
            const rightY = (-sin * sideDist - cos * backDist) * sy;

            // Draw directly in clip space with identity matrix
            gl.uniformMatrix3fv(u_matrix, false, new Float32Array([1,0,0, 0,1,0, 0,0,1]));

            // Draw filled triangle
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                tipX, tipY, leftX, leftY, rightX, rightY
            ]), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(u_color, [0.2, 0.85, 0.2, 1.0]);
            gl.drawArrays(gl.TRIANGLES, 0, 3);

            // Restore world matrix
            gl.uniformMatrix3fv(u_matrix, false, getMatrix());
        }

        function drawVehicle() {
            const size = 5;
            const cos = Math.cos(vehicle.heading);
            const sin = Math.sin(vehicle.heading);

            // Draw vehicle at camera position (center of view)
            const cx = camera.x;
            const cy = camera.y;

            // Triangle pointing in heading direction
            const tip = [cx + sin * size, cy + cos * size];
            const left = [cx - cos * size/3 - sin * size/2, cy + sin * size/3 - cos * size/2];
            const right = [cx + cos * size/3 - sin * size/2, cy - sin * size/3 - cos * size/2];

            drawLines([
                tip[0], tip[1], left[0], left[1],
                left[0], left[1], right[0], right[1],
                right[0], right[1], tip[0], tip[1]
            ], [0.2, 1, 0.2, 1]); // Lime green
        }

        function drawBoundary() {
            if (boundary.length < 4) return;
            drawLines(boundary, [1, 1, 0, 1]); // Yellow
        }

        // ===== Main Render Loop =====
        function render(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            // Update simulator
            if (simulator.enabled) {
                updateSimulator(dt);
            }

            // Camera follows vehicle
            camera.x = vehicle.x;
            camera.y = vehicle.y;

            // Clear
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Setup
            gl.useProgram(program);
            gl.uniformMatrix3fv(u_matrix, false, getMatrix());

            // Draw cached grid (uses texture for smooth scrolling)
            drawCachedGrid();

            // Set up matrix for world-space objects
            gl.useProgram(program);
            gl.uniformMatrix3fv(u_matrix, false, getMatrix());
            drawBoundary();
            drawVehicleScreenSpace(); // Use screen-space rendering for stable vehicle

            // Update UI
            updateUI();

            requestAnimationFrame(render);
        }

        // ===== Simulator =====
        function updateSimulator(dt) {
            // Update heading based on steer angle and speed
            const turnRate = simulator.steerAngle * 0.5 * (simulator.speed / 10);
            vehicle.heading += turnRate * dt;

            // Update position based on heading and speed
            vehicle.x += Math.sin(vehicle.heading) * simulator.speed * dt;
            vehicle.y += Math.cos(vehicle.heading) * simulator.speed * dt;
        }

        // ===== UI Updates =====
        function updateUI() {
            document.getElementById('speed-value').textContent = (simulator.speed * 3.6).toFixed(1);
            document.getElementById('heading-value').textContent = ((vehicle.heading * 180 / Math.PI) % 360).toFixed(0);
            document.getElementById('easting-value').textContent = vehicle.x.toFixed(1);
            document.getElementById('northing-value').textContent = vehicle.y.toFixed(1);
        }

        // ===== Touch/Mouse Handlers =====
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let t of e.changedTouches) {
                touches[t.identifier] = { x: t.clientX, y: t.clientY };
            }
            if (Object.keys(touches).length === 1) {
                isPanning = true;
                const t = e.touches[0];
                panStart = { x: t.clientX, y: t.clientY };
            } else if (Object.keys(touches).length === 2) {
                const [t1, t2] = e.touches;
                lastPinchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                // Pinch zoom
                const [t1, t2] = e.touches;
                const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                if (lastPinchDist > 0) {
                    camera.zoom *= dist / lastPinchDist;
                    camera.zoom = Math.max(0.1, Math.min(50, camera.zoom));
                }
                lastPinchDist = dist;
            }
            // Note: Pan disabled while simulator camera follows vehicle
        });

        canvas.addEventListener('touchend', (e) => {
            for (let t of e.changedTouches) {
                delete touches[t.identifier];
            }
            if (Object.keys(touches).length < 2) {
                lastPinchDist = 0;
            }
            isPanning = false;
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom *= factor;
            camera.zoom = Math.max(0.1, Math.min(50, camera.zoom));
        });

        // ===== Button Handlers =====
        document.getElementById('zoom-in').addEventListener('click', () => {
            camera.zoom *= 1.2;
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            camera.zoom *= 0.8;
        });

        // ===== WebSocket Connection =====
        let ws = null;
        let wsConnected = false;

        function connectWebSocket() {
            const wsUrl = `ws://${window.location.host}/ws`;
            console.log('Connecting to WebSocket:', wsUrl);

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                wsConnected = true;
                document.getElementById('gps-dot').style.background = '#1ABC9C';
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                wsConnected = false;
                document.getElementById('gps-dot').style.background = '#E74C3C';
                // Reconnect after 2 seconds
                setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);

                if (msg.type === 'gps') {
                    // Update vehicle from server GPS data
                    vehicle.x = msg.data.easting;
                    vehicle.y = msg.data.northing;
                    vehicle.heading = msg.data.heading * Math.PI / 180; // degrees to radians
                    simulator.speed = msg.data.speed / 3.6; // km/h to m/s
                }
                else if (msg.type === 'connected') {
                    console.log('Connected to server, ID:', msg.connectionId);
                    if (msg.simulator) {
                        simulator.enabled = msg.simulator.running;
                        document.getElementById('sim-toggle').classList.toggle('active', simulator.enabled);
                    }
                }
                else if (msg.type === 'simulator') {
                    console.log('Simulator message:', msg);
                }
            };
        }

        function sendWsMessage(msg) {
            if (ws && wsConnected) {
                ws.send(JSON.stringify(msg));
            }
        }

        // Override simulator button handlers to send to server
        document.getElementById('sim-toggle').addEventListener('click', (e) => {
            simulator.enabled = !simulator.enabled;
            e.target.classList.toggle('active', simulator.enabled);
            sendWsMessage({ type: 'simulator', action: simulator.enabled ? 'start' : 'stop' });
        });

        document.getElementById('steer-left').addEventListener('click', () => {
            simulator.steerAngle = Math.max(-45, simulator.steerAngle - 5);
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: simulator.steerAngle });
        });

        document.getElementById('steer-right').addEventListener('click', () => {
            simulator.steerAngle = Math.min(45, simulator.steerAngle + 5);
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: simulator.steerAngle });
        });

        document.getElementById('steer-zero').addEventListener('click', () => {
            simulator.steerAngle = 0;
            sendWsMessage({ type: 'simulator', action: 'setSteer', value: 0 });
        });

        document.getElementById('accel').addEventListener('click', () => {
            // Speed in km/h, max 20 km/h, increment by 2 km/h
            const currentKmh = simulator.speed * 3.6;
            const newKmh = Math.min(20, currentKmh + 2);
            simulator.speed = newKmh / 3.6;
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: newKmh });
        });

        document.getElementById('stop').addEventListener('click', () => {
            simulator.speed = 0;
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: 0 });
            // Also reset position to origin
            vehicle.x = 0;
            vehicle.y = 0;
            vehicle.heading = 0;
            smoothCamX = 0;
            smoothCamY = 0;
            smoothedHeading = 0;
            sendWsMessage({ type: 'simulator', action: 'setPosition', latitude: 40.7128, longitude: -74.0060 });
        });

        document.getElementById('decel').addEventListener('click', () => {
            const currentKmh = simulator.speed * 3.6;
            const newKmh = Math.max(0, currentKmh - 2);
            simulator.speed = newKmh / 3.6;
            sendWsMessage({ type: 'simulator', action: 'setSpeed', value: newKmh });
        });

        // Connect to WebSocket on load
        connectWebSocket();

        // ===== Start =====
        requestAnimationFrame(render);

        console.log('AgOpenGPS WebGL POC loaded - with WebSocket');
    </script>
</body>
</html>
